	Здесь описано используемое программное обеспечение. К нему относится 4
драйвера, 3 библиотеки, 1 демон и одна программа запускаемая однажды при
инициализации. Так же есть сервисные программы, которые можно использовать для
тестирования.

=================================================
Стек драйверов и "железная" архитектура системы
=================================================
	В устройстве используются чипы Vinetic-2CPE v2.2 от Infineon. Для работы с
чипами Infineon предоставляет стек драйверов (drv_daa, drv_vinetic, drv_tapi).
Так как чипы работают на pci-плате, а на одном роутере может быть несколько
таких плат, разработан драйвер для инициализации этих плат и организации
обмена данными с чпами через pci-шину. На основе чипов построены сменные
суб-модули, каждый из который содержит 2 канала (FXS, FXO или TF) Для TF-канала
также устанавливается режим работы (2-х или 4-х проводка) перемычкой на
суб-модуле. Каждый канал имеет свой номер в зависимости от местоположения 
суб-модуля на VoIP-модуле, а модуля на роутере. 
Слоты для плат нумеруются в следующей последовательности:

===(1)=== ===(3)===
===(2)=== ===(4)===

В каждую плату можно вставить до 4 суб-модулей по два канала в каждом.
Нумерация каналов идёт последовательно слева на право на VoIP-модуле и в
указанном порядке на слотах. Нумерация начинается с нуля. Таким образом, если
мы сконструируем VoIP систему следующим образом:

(FXS)(emp)(FXO)(emp) (emp)(FXS)(FXO)(FXS)
(emp)(emp)(emp)(emp) (emp)(TF)(TF)(emp)

то получим набор каналов со следующими номерами:
FXS : 0
FXS : 1
FXO : 4
FXO : 5
FXS : 18
FXS : 19
FXO : 20
FXO : 21
FXS : 22
FXS : 23
TF : 26
TF : 27
TF : 28
TF : 29

	В том виде как стек драйверов поставляется откомпилировать его не удалось, 
поэтому были написаны патчи с небольшими исправлениями. Кроме этого, у 
tapi-драйвера увеличено максимальное количество поддерживаемых FXO-каналов 
(с 16 до 32), и пофиксина неправильная инициализация типа канала (FXO/FXS). 
У vinetic-драйвера увеличено количество выделяемой памяти для 
отладочных целей (замечены случаи, когда её не хватало), а также изменена 
функция VINETIC_Host_AccessTest для более удобного тестирования программой 
iotst (более подробно о характере изменений см. патч vinetic.patch). Для
DAA-драйвера описана дополнительная плата (в соответстви с шаблоном) и 
соответственно настроен процесс компиляции. Также немного изменён интерфейс
пользователя кода, описывающего плату - иначе пришлось бы писать много нудного
повторяющегося кода. Ещё в daa несколько улучшен детектор звонка, чтобы
драйвер меньше реагировал на различные помехи в линии. В оригинальном
daa-драйвере звонок определяется по трём передним фронтам импульса, пришедшим
с разрывом не более 70 мс. Сейчас добавлен анализ периодичности приходящих
импульсов и то, укладываются ли они в стандартные частоты сигнала звонка
(15-55 Гц). Также в makefile добавлена возможность компиляции для ядер
версии 2.6. Также реализована возможность импульсного набора номера.
За более подробной информацией по драйверам от infineon
обращайтесь к документации от него же. Далее будет дан лишь краткий обзор того
что как работает.

------------
drv_vinetic
------------
	Это драйвер для работы с чипами Vinetic различных модификаций.
Подробнейшую информацию по этому драйверу можно получить из документа
предоставляемого Infineon`ом Vinetic_CPE_System_descr_UM.pdf. Здесь лишь стоит
упомянуть, что реализация идёт вразрез с данными там рекомендациями в пункте
3.2 (Reset considerations). На VoIP плате не реализован отдельный от
общесистемного reset для чипов. Поэтому при инициализации чипов всё идёт не по
указанной схеме, а reset поднимается и опускается до инициализации. Но это не
важно так как обмена данных во время инициализации (BASICDEV_INIT) не
происходит. Фактически, происходит инициализация внутренних структур ядра по
переданным через ioctl параметрам. Эти параметры передаются в структуре 

typedef struct
{
	VIN_ACCESS AccessMode;
	IFX_uint32_t nBaseAddress;
	IFX_int32_t nIrqNum;
} VINETIC_BasicDeviceInit_t;

	На каком прерывании висит та или иная материнская VoIP-плата (а 
соответственно и все VoIP-чипы на ней), а также адрес в памяти, выделенный 
для общения с этими чипами определяет драйвер drv_sgatab и выдёт по запросу.
Такой запрос составляет программа svi. Получив эти данные от drv_sgatab она
делает базовую инициализацию всех чипов, передавая эти данные драйверу
drv_vinetic.

------------
drv_daa
------------
	Это драйвер для обеспечения взаимодействия с FXO-каналами. Он
предоставляет интерфейс позволяющий описывать каким образом чип будет получать
информацию о событиях, происходящих на FXO-канале (входящий звонок) и куда ему
выдавать информацию о генеримых им самим событиях (подняли/опустили трубку).
Для обмена такой информации используется GPIO (General Purpose IO) vinetic`а.
Пины 0 и 2 - hook и ring для нулевого канала и пины 4 и 6 для первого
соответственно. Интерфейс и способ описания платы хорошо документированы в
исходных кодах daa-драйвера. Этот интерфейс немного изменён (там где это нужно
передаётся номер FXO-канала) для более компактного описания платы. Все
изменения можно посмотреть в патче (daa.patch).

------------
drv_tapi
------------
	Это драйвер высокого уровня, предоставляющий единообразный интерфейс для
работы с различным VoIP-оборудованием от Infineon и использующий для связи с
оборудованием низкоуровневые драйвера (такие как drv_vinetic). Подробнейшея
информация по этому драйверу есть в документации от Infineon
TAPI_V3_UM_PR_Rev16.pdf.

------------
drv_sgatab
------------
	Драйвер для инициализации в системе VoIP-плат. Он определяет в какие
разёмы подключены платы, на каком висят прерывании и какие диапазоны памяти им
выделены, a также типы субмодулей (FXO/FXS/TF) подключённых к VoIP-модулям. 
По запросу ioctl из user space драйвер эту информацию выдаёт. Типы субмодулей
определяются по содержимому конфигурационного регистра PCI-платы
PCI_SUBSYSTEM_ID. Этот драйвер предоставляет информацию о каналах (их типах, и
положении) через файл /proc/drivers/sgatab/channels.


=================================================
Исбользуемые библиотеки
=================================================
------------
config
------------
	Используется для чтения конфигурации в демоне svd и инициализаторе svi.

------------
sofia-sip
------------
	Используется для организации взаймодействия по SIP-протоколу в svd-демоне.

------------
ab
------------
	Библиотека для упрощения доступа к каналам и несущих их устройствам. Также
упрощён интерфейс для часто выполняемых действий, как то генерация и ловля 
событий, инициация передачи факсимильных сообщений, настройка параметров 
rtp-протокола, и т.д. Используется в svd-демоне и тестовых программах. Более
подробную информацию о программной структуре библиотеки можно получить при
помощи doxygen.


=================================================
Основные программы
=================================================
------------
svi
------------
	Осуществляет загрузку стека драйверов в систему, создаёт файлы устройств
для коммуникации с каналами, инициализирует драйвера и загружает прошивку для
каналов. Также выполняет необходимые действия после загрузки прошивки
(маскирование событий на каналах и т.д.). Использует библиотеку config для
определения типа TF-каналов и загрузки для них соответствующей прошивки. 
Может быть запущен с разными ключами для отмены какого-либо этапа загрузки 
(используется при тестировании оборудования). Для получения более подробной 
информации смотрите svi -h. 

!! ВНИМАНИЕ !!
Если при запуске производилась инициализация чипов прошивкой, то повторный запуск 
с такой инициализацией приведёт к сбою. Сбросить залитую прошивку можно только
выключив и заново включив роутер.

------------
svd
------------
	Демон, реализующий SIP-стек и ловящий / отправляющий события с / на VoIP
оборудование. Использует библиотеки: 
	config - для чтения конфигурационных файлов;
	sofia-sip - для работы с sip-стеком;
	ab - для работы с VoIP-оборудованием.
По каждой библиотеке есть подробная документация либо на сайте проекта, либо в
исходных кодах, которую можно выделить при помощи утилиты doxygen.
	Изменение кофигурационных файлов следует производить только через
веб-интерфейс так как после перезагрузки роутера изменения, внесённые вручную,
будут утеряны. Веб-интерфейс подробно описан в web.txt.
	Для отладочных целей удобно запускать демон с ключом -dX, где X - степень
подробности отладочных сообщений, изменяется от 0 до 9 (мало - много). Более
подробную информацию о программной структуре svd можно выделить при помощи
doxygen их исходного кода.

------------
svd_if
------------
	Программа, обеспечивающая интерфейс для управления демоном. На данный
момент поддерживается возможность получать статистику по RTCP-сеансу и по
jitter buffer`у. Для обмена сообщениями используется сокет AF_UNIX и протокол
SOCK_DGRAM.

------------
svc
------------
	Демон, запускаемый вместе со svi и следящий за тем, что SVD запущен. Если
SVD не был запущен на протяжении 9 секунд (возможно произошёл сбой), то SVC
очищает все каналы от накопившегося rtp-трафика и выключает его генерацию.
Если этого не сделать, то память будет постепенно съедена и роутер станет
недоступен через веб. А так хоть будет проще посмотреть из-за чего SVD
свалился. Использует библиотеку ab. Возможен запуск с ключём --clear-and-exit.
В таком режиме svc просто очищает все каналы и выходит, не демонизируясь и не
оставляя каких-либо логов.

=================================================
Вспомогательные программы для тестирования
=================================================
------------
etst
------------
	Тестирует каналы на обнаружение и генерацию событий. Для работы с этой
программой нужно замкнуть тестируемые каналы друг на друга (попарно FXS-FXO) и
запустить тест. Каналы начинают по очереди генерировать события. Программа
ищет какой канал улавливает это событие и выдаёт результат на экран. Для более
подробного вывода программу нужно запускать с ключом -v.

------------
vtst
------------
	Тестирует передачу голоса с канала на канал. Для этого нужно подрлючить 2
телефона к FXS-портам запустить программу с желаемыми настройками (см. --help)
и поднять трубки на телефонах.

------------
iotst
------------
	Тестирует ввод вывод на чипы vinetic. Для этого теста необходимо не
инициализировать чипы прошивкой. Для этого svi нужно запускать с ключом -c. 
Этого можно добиться подправив скрипт, управляющий запуском / остановкой /
перезапуском VoIP-программ. В /etc/init.d/rcvoip изменить svi на svi -c, 
сохранить и перезапустить роутер. Программа тестирует запись/чтение на чип 
и выводит статистику на терминал.


=================================================
Расположение частей VoIP-комплекса
=================================================
	После инсталляции прошивки на роутер, компоненты VoIP-комплекса можно найти
в следующих каталогах:
	* /lib/modules/2.6.16/
		Здесь расположен стек драйверов (vinetic, daa, tapi, sgatab).
	* /lib/firmware/
		Здесь лежит прошивка для чипов Vinetic.
	* /etc/init.d/
		Скрипт, управляющий стартом / остановом / перезапуском svd.
	* /etc/svd/
		Конфигурационные файлы для svd.
	* /etc/svi.conf
		Конфигурационный файл для svi.
	* /bin/
		Программные ("запускаемые") модули комплекса - svi, svd, etst, vtst,
		iotst.

=================================================
Процесс загрузки
=================================================
------------
Обычный старт
------------
	Далее будет описан в общих и основных чертах процесс старта VoIP-системы 
после включения роутера. 
	ОС на роутере перебирает все скрипты по шаблону S\d+<name> из каталога
/etc/init.d и запускает их. \d+ - означает любое целое число. Используется для
задания порядка перебора. В нашем случае S95rcvoip является ссылкой на скрипт
rcvoip и запускает его после запуска всех остальных скриптов с ключом start.
Основное, что делает rc-скрипт, запущенный с этим ключом - запускает SVI,
затем убивает (на всякий случай) и снова запускает SVD. 
	Псосле запуска, SVI загружает стек VoIP-драйверов, создаёт файл устройства 
для SGATAB, чтобы узнать у него конфигурацию VoIP-системы (сколько плат 
установлены и какого типа модули на них стоят). SGATAB получает эту информацию, 
от системы. По VENDOR_ID и DEVICE_ID - SGATAB определяет наличие VoIP-хостплаты, 
а по SUBSYSTEM_ID хостплаты определяет наличие и тип VoIP-субмодулей на этой плате.
Выяснив конфигурацию VoIP-системы, SVI создаёт соответствующие файлы устройств
для общения с элементами этой системы. Потом читает конфигурационный файл, 
инициализирует драйвера, загружает прошивку для каналов и настраивает эти каналы. 
Сделав всё это, SVI завершает свою работу.
	После старта SVD проверяет и обрабатывает ключи запуска, демонизируется,
считывает конфигурационные файлы инициализирует используемые библиотеки
(sofia-sip и ab), инициализирует слушателей (listeners) на события с
SIP-стека и с VoIP-устройств и запускает бесконечный цикл, выходит из которого
только для обработки событий.

------------
Отладочный старт
------------
	При изменении, допустим, svd удобно не перезагружать каждый раз роутер, а
запускать svd из консоли самостоятельно. Для этого нужно:
1. Подключиться к роутеру через RS232(COM)-порт.
2. Загрузиться, авторитоваться под логином root, пароль 1234.
3. Заменить /bin/svd на скрипт-заглушку, чтобы не происходил старта svd после
перезагрузки и, что более важно, изменения параметров демона через
веб-интерфейс.
4. Скачать обновлённую версию демона командой
# tftp -g -r svd <ip-адрес компьютера, с которого происходит скачивание>
5. Запустить svd с ключом отладки
# ./svd -d9
6. Теперь можно наблюдать отладочные сообщения.

