diff -Naur net-snmp-5.1.2-old/agent/Makefile.in net-snmp-5.1.2-new/agent/Makefile.in
--- net-snmp-5.1.2-old/agent/Makefile.in	2009-06-27 07:52:36.000000000 +0700
+++ net-snmp-5.1.2-new/agent/Makefile.in	2009-06-27 07:52:19.000000000 +0700
@@ -75,8 +75,10 @@
 # Objects
 #
 
+SHDSL_LMIBOBJS = mibgroup/mibII/shdsl/app-if/comm.lo mibgroup/mibII/shdsl/app-if/app_comm.lo mibgroup/mibII/shdsl/app-if/app_comm_cli.lo mibgroup/mibII/shdsl/app-if/app_comm_srv.lo mibgroup/mibII/shdsl/app-if/app_frame.lo
+
 # libnetsnmpmib objects.
-LMIBOBJS	= @mibgroup_list_lo@ mib_modules.lo auto_nlist.lo
+LMIBOBJS	= @mibgroup_list_lo@ mib_modules.lo auto_nlist.lo $(SHDSL_LMIBOBJS)
 MIBOBJS		= @mibgroup_list_o@ mib_modules.o auto_nlist.o
 
 # libnetsnmpagent objects
@@ -94,7 +96,7 @@
 #
 # Define OBJS and LOBJS for clean target (just this directory)
 #
-OBJS		= $(LIBAGENTOBJS)  $(AGENTOBJS)  mib_modules.o  auto_nlist.o
+OBJS		= $(LIBAGENTOBJS)  $(AGENTOBJS)  mib_modules.o  auto_nlist.o  
 LOBJS		= $(LLIBAGENTOBJS) $(LAGENTOBJS) mib_modules.lo auto_nlist.lo
 
 
@@ -124,7 +126,7 @@
 	$(RANLIB) libnetsnmpagent.$(LIB_EXTENSION)$(LIB_VERSION)
 
 libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION):    ${LMIBOBJS}
-	$(LIB_LD_CMD) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION) ${LMIBOBJS}  $(LIB_LD_LIBS) $(MIBS_RELINK_LIBS) $(LIBSENSORS)
+	$(LIB_LD_CMD) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION) ${LMIBOBJS} -lstdc++ $(LIB_LD_LIBS) $(MIBS_RELINK_LIBS) $(LIBSENSORS)
 	$(RANLIB) libnetsnmpmibs.$(LIB_EXTENSION)$(LIB_VERSION)
 
 embedperlinstall:
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/host/hr_storage.c net-snmp-5.1.2-new/agent/mibgroup/host/hr_storage.c
--- net-snmp-5.1.2-old/agent/mibgroup/host/hr_storage.c	2004-06-19 01:39:14.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/host/hr_storage.c	2009-06-27 07:52:20.000000000 +0700
@@ -743,20 +743,21 @@
                 break;
             }
         return (u_char *) & long_return;
+
     case HRSTORE_FAILS:
-        if (store_idx > HRS_TYPE_FIXED_MAX)
-#if NO_DUMMY_VALUES
-	    goto try_next;
-#else
+        if (store_idx > HRS_TYPE_FIXED_MAX){
+/*#if NO_DUMMY_VALUES
+			printf("HRSTORE_FAILS - store_idx > HRS_TYPE_FIXED_MAX: goto\n");
+		    goto try_next;
+#endif*/
             long_return = 0;
-#endif
-        else
+        }else
             switch (store_idx) {
             case HRS_TYPE_MEM:
             case HRS_TYPE_SWAP:
-#if NO_DUMMY_VALUES
+/*#if NO_DUMMY_VALUES
                 goto try_next;
-#endif
+#endif */
                 long_return = 0;
                 break;
 #if !defined(linux) && !defined(solaris2) && !defined(hpux10) && !defined(hpux11)  && defined(MBSTAT_SYMBOL)
@@ -765,9 +766,9 @@
                 break;
 #endif                          /* !linux && !solaris2 && !hpux10 && !hpux11 && MBSTAT_SYMBOL */
             default:
-#if NO_DUMMY_VALUES
+/*#if NO_DUMMY_VALUES
                 goto try_next;
-#endif
+#endif */
                 long_return = 0;
                 break;
             }
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/Makefile.in net-snmp-5.1.2-new/agent/mibgroup/Makefile.in
--- net-snmp-5.1.2-old/agent/mibgroup/Makefile.in	2002-04-20 14:30:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/Makefile.in	2009-06-27 07:52:19.000000000 +0700
@@ -2,6 +2,7 @@
 
 CPPFLAGS=-I../../include -I$(top_srcdir)/include \
 	-I. -I../.. -I$(srcdir) -I$(srcdir)/../.. \
+	-ImibII/shdsl/include \
 	-I$(srcdir)/../../snmplib -I$(srcdir)/.. -I.. @CPPFLAGS@ $(LIB_CFLAGS)
 
 # Need a special .c -> .o definition here to make sure we place the
@@ -10,9 +11,12 @@
 .c.o:
 	$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<
 
-OBJS = @module_list_o@
-LOBJS = @module_list_lo@
-SRCS = @module_list_c@
-
+SHDSL_OBJS = mibII/shdsl/app-if/comm.o mibII/shdsl/app-if/app_comm.o mibII/shdsl/app-if/app_comm_cli.o mibII/shdsl/app-if/app_comm_srv.o mibII/shdsl/app-if/app_frame.o
+SHDSL_LOBJS = mibII/shdsl/app-if/comm.lo mibII/shdsl/app-if/app_comm.lo mibII/shdsl/app-if/app_comm_cli.lo mibII/shdsl/app-if/app_comm_srv.lo mibII/shdsl/app-if/app_frame.lo
+SHDSL_SRCS = mibII/shdsl/app-if/comm.cpp mibII/shdsl/app-if/app_comm.cpp mibII/shdsl/app-if/app_comm_cli.cpp mibII/shdsl/app-if/app_comm_srv.cpp mibII/shdsl/app-if/app_frame.cpp
+
+OBJS = @module_list_o@  $(SHDSL_OBJS)
+LOBJS = @module_list_lo@ $(SHDSL_LOBJS)
+SRCS = @module_list_c@ $(SHDSL_SRCS)
 all: standardall $(LOBJS)
 
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm_cli.cpp	2008-05-22 15:08:44.000000000 +0700
@@ -0,0 +1,97 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm_cli.h>
+#include <eoc_debug.h>
+
+app_comm_cli::
+app_comm_cli(char *sock_name,int quiet):app_comm(sock_name)
+{
+    struct sockaddr_un saun;
+    struct stat sbuf;    
+    int s;
+    int ret=0,len;
+	int dlev = debug_lev - 1;
+
+	if( quiet ){
+		dlev = debug_lev + 1;
+	}
+		
+
+    // Check path exist
+    if( (ret = stat(sname,&sbuf)) ){
+        PDEBUG(dlev,"Problem with socket (%s)",sname);
+        error_init = 1;
+        return;
+    }  
+    if( !S_ISSOCK(sbuf.st_mode) ){
+		PDEBUG(dlev,"Not a socket (%s)",sname);
+        error_init = 1;	
+		return;
+    }
+
+    // Create socket
+    if ( (s = socket(AF_UNIX, SOCK_STREAM, 0) ) < 0) {
+    	PDEBUG(dlev,"Cannot create socket (%s)",sname);
+        error_init = 1;
+		return;    
+    }
+
+    saun.sun_family = AF_UNIX;
+    strcpy(saun.sun_path,sname);
+	
+    len = sizeof(saun.sun_family) + strlen(saun.sun_path);
+    if (connect(s,(struct sockaddr*)&saun, len) < 0) {
+		PDEBUG(dlev,"Cannot connect to (%s)",sname);
+        error_init = 1;
+		sfd = -1;
+		return;
+    }
+    sfd = s;
+}
+
+app_comm_cli::
+~app_comm_cli()
+{
+    close(sfd);
+}
+
+int app_comm_cli::
+complete_wait()
+{
+    if( sfd < 0 ){
+		//PDEBUG(DERR,"Error wile initialisation\n");
+		return -1;
+    }
+
+    if (FD_ISSET(sfd,&socks))
+		return 1;
+    return 0;
+}
+
+int app_comm_cli::
+send(char *buf,size_t size)
+{
+    if( sfd < 0 ){
+		//PDEBUG(DERR,"Error wile initialisation\n");
+		return -1;
+    }
+    return _send(sfd,buf,size);
+
+}
+
+ssize_t app_comm_cli::
+recv(char *&buf)
+{
+    if( sfd < 0 ){
+		//PDEBUG(DERR,"Error wile initialisation\n");
+		return -1;
+    }
+    return _recv(sfd,buf);
+}
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm.cpp	2008-05-22 15:08:44.000000000 +0700
@@ -0,0 +1,97 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm.h>
+#include <eoc_debug.h>
+
+int app_comm::
+set_nonblock(int sock)
+{
+    int opts;
+
+    opts = fcntl(sock,F_GETFL);
+    if (opts < 0) {
+    	PERROR("fcntl(F_GETFL)");
+    	return -errno;
+    }
+    opts = (opts | O_NONBLOCK);
+    if (fcntl(sock,F_SETFL,opts) < 0) {
+    	PERROR("fcntl(F_SETFL)");
+    	return -errno;
+    }
+    return 0;
+}
+
+int app_comm::
+build_select_list()
+{
+    if( sfd < 0 )
+		return -1;
+    // blank fd set
+    FD_ZERO(&socks);
+    // fill fd set
+    FD_SET(sfd,&socks);
+    hisock = sfd;
+    return 0;
+}
+
+int app_comm::
+wait(int sec)
+{
+    int count=0;
+    struct timeval timeout;  /* Timeout for select */	
+
+    timeout.tv_sec = sec;
+    timeout.tv_usec = 0;
+    if( build_select_list() )
+		return -1;
+
+    count = select(hisock+1,&socks,(fd_set *)0,(fd_set *)0, &timeout);
+    if( count < 0) {
+        PERROR("Select");
+        return -errno;
+    }
+    if( count ){
+    	return complete_wait();
+    }
+    return count;
+}
+
+int app_comm::
+_send(int fd,char *buf,size_t size)
+{
+    size_t nsize;
+    if( (nsize=::send(fd,buf,size,0)) != size ){
+		//        PDEBUG(DERR,"error: %d",nsize); 
+        return -EAGAIN;
+    }
+
+    return 0;
+}	
+
+ssize_t app_comm::
+_recv(int fd,char *&buf)
+{
+    char *frame = new char[BLOCK_SIZE];
+    int frame_len;
+    int ret;
+    
+    if( (frame_len = ::recv(fd,frame,BLOCK_SIZE,MSG_PEEK|MSG_DONTWAIT) ) <= 0 ){
+		delete[] frame;
+		return -EAGAIN;
+	}
+    ret = ::recv(fd,(char*)frame,frame_len,MSG_DONTWAIT);
+    if( frame_len != ret ){
+		delete[] frame;
+		return -EAGAIN;
+	}
+
+    buf = frame;
+    return frame_len;
+}
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_comm_srv.cpp	2008-05-22 15:08:44.000000000 +0700
@@ -0,0 +1,186 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <app-if/app_comm_srv.h>
+#include <eoc_debug.h>
+
+app_comm_srv::
+app_comm_srv(char *sock_path,char *sock_name) : app_comm(sock_path,sock_name)
+{
+    struct sockaddr_un saun;
+    struct stat sbuf;
+    int s;
+    int ret=0,len;
+    
+    // Check path exist
+    if( (ret = stat(sock_path,&sbuf)) ){
+		if( errno != ENOENT ){
+			PERROR("Error getting info about %s",sock_path);
+			return;
+		}
+		if( mkdir(sock_path,(S_IRWXU | S_IRGRP | S_IXGRP)) ){
+			PERROR("Cannot create dir %s",sock_path);
+			return;
+		}
+		if( stat(sock_path,&sbuf) ){
+			PERROR("Error creating dir %s",sock_path);
+			return;
+		}
+    }  
+    if( !S_ISDIR(sbuf.st_mode) ){
+		PDEBUG(DERR,"Error: %s is not directory",sock_path);
+		return;
+    }
+
+    // Create socket
+    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+    	PERROR("Cannot create socket");
+		return;    
+    }
+			    
+    if( unlink(sname) ){
+		if( errno != ENOENT ){
+			PERROR("Cannot unlink (%s)",sname);
+			return;
+		}
+    }
+    
+    saun.sun_family = AF_UNIX;
+    strcpy(saun.sun_path,sname);
+    len = sizeof(saun.sun_family) + strlen(saun.sun_path);
+    if(bind(s, (const sockaddr*)&saun, len) < 0) {
+    	PERROR("Cannot bind server with socket (%s)",sname);
+		return;
+    }
+    // open socket for listening
+    if(listen(s,MAX_CONNECTIONS) < 0) {
+    	PERROR("Error trying listen socket (%s)",sname);
+		return;
+    }
+    
+    // setup non blocking
+    if( set_nonblock(s) )
+		return; /* ?? */
+
+    // setup descriptor
+    sfd = s;
+    conn_num = 0;
+
+    return;			
+}
+
+
+int app_comm_srv::
+build_select_list()
+{
+    int i;
+    if( sfd < 0 )
+		return -1; 
+    // blank fd set
+    FD_ZERO(&socks);
+    // fill fd set
+    FD_SET(sfd,&socks);
+    hisock = sfd;
+    for(i=0; i < conn_num; i++) {
+        FD_SET(conn_fd[i],&socks);
+		if ( conn_fd[i] > hisock)
+			hisock = conn_fd[i];
+    }
+    return 0;
+}
+
+int app_comm_srv::
+new_connection()
+{
+	int i,ret=0;
+	int nsock; /* Socket file descriptor for incoming connections */
+
+	nsock = accept(sfd, NULL, NULL);
+	if( nsock < 0) {
+		PERROR("Error: while accept incoming connection of (%s)",sname);
+		return -errno;
+	}
+	if( (ret = set_nonblock(nsock)) ){
+		close(nsock);
+		return ret;
+	}
+
+	if( conn_num == MAX_CONNECTIONS ){
+		close(nsock);
+		PDEBUG(DINFO,"Close new connection - no room left");
+		return -ENOMEM;
+	}
+	// add to socket list
+	conn_fd[conn_num++] = nsock;
+	return 0;
+}
+
+int app_comm_srv::
+complete_wait()
+{
+    int i,j;
+    int num_act=0;
+    char tmp;
+	
+    memset(conn_act,0,sizeof(conn_act));	
+    for (i=0; i<conn_num; i++) {
+		if (FD_ISSET(conn_fd[i],&socks)){
+			if( ::recv(conn_fd[i],&tmp,1,MSG_PEEK|MSG_DONTWAIT) < 1 ){
+				PDEBUG(DINFO,"Connection closed");
+				close(conn_fd[i]);
+				// shift descriptors
+				for(j=i;j<conn_num;j++)
+					conn_fd[j]=conn_fd[j+1];
+				conn_num--;
+				i--;
+			}else{
+				conn_act[i] = 1;
+				num_act++;
+			}
+		}
+    }
+    if (FD_ISSET(sfd,&socks))
+		new_connection();
+    return num_act;
+}
+
+
+int app_comm_srv::
+next_fd(){
+    int i;
+    for(i=0;i<conn_num;i++){
+		if( conn_act[i] ){
+			conn_act[i] = 0;
+			return i;
+		}
+    }
+    return -1;
+}
+
+int app_comm_srv::
+send(int c_num,char *buf,size_t size)
+{
+    if( !c_num ){
+		return _send(sfd,buf,size);
+    }else{
+		if( c_num > conn_num )
+			return -1;
+		return _send(conn_fd[c_num-1],buf,size);
+    }
+}
+
+ssize_t app_comm_srv::
+recv(int &c_idx,char *&buf)
+{
+    if( (c_idx = next_fd()) <0 ) 
+		return 0;
+    c_idx++;
+	PDEBUG(DERR,"Receive from %d fd",c_idx);
+    return _recv(conn_fd[c_idx-1],buf);
+}
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/app_frame.cpp	2009-04-18 12:15:23.000000000 +0700
@@ -0,0 +1,191 @@
+#include <app-if/app_frame.h>
+
+app_frame::
+app_frame(app_ids id,app_types type,roles role,u8 act_seconds,char *dname){
+	u32 psize,csize;
+	int offs;
+
+	if( (offs = size_by_id(id,type,psize,csize) ) <0 ){
+	    buf = NULL;
+	    buf_size = 0;
+	    return;
+	}
+	buf_size = offs;
+	if( !(buf = new char[buf_size]) ){
+		buf = NULL;
+	    buf_size = 0;
+	    return;
+	}
+	memset(buf,0,buf_size);
+	hdr = (app_frame_hdr *)buf;
+	hdr->len = buf_size;
+	hdr->psize = psize;
+	hdr->csize = csize;
+	hdr->id = (u8)id;
+	hdr->type = (u8)type;
+	hdr->role = (u8)role;
+	if( time(&hdr->tstamp) < 0){
+		//   PDEBUG(DERR,"Error getting current time");
+	}
+	hdr->act_sec = act_seconds;
+	memcpy(hdr->dname,dname,strnlen(dname,SPAN_NAME_LEN));
+}
+
+app_frame::
+app_frame(char *b,int size){
+    u32 psize,csize;
+    int offs;
+    buf = b;
+    buf_size = size;
+    hdr = (app_frame_hdr *)buf;
+    // GET correct parameters of frame
+    if( (offs = size_by_id((app_ids)hdr->id,(app_types)hdr->type,psize,csize) ) <0 ){
+        buf = NULL;
+        buf_size = 0;
+        PDEBUG(DERR,"Cannot get info about frame id = %d",hdr->id);
+        return;
+    }
+    if( (hdr->psize != psize) || (hdr->csize != csize) ){
+        PDEBUG(DERR,"Error in app_frame header: id=%d, psize=(%d not %d), csize=(%d not %d)",
+			   hdr->id,hdr->psize,psize,hdr->csize,csize);
+		negative();
+    }
+}
+
+app_frame::
+~app_frame(){
+    if(buf)
+        delete[] buf;
+}
+
+
+int app_frame::
+size_by_id(app_ids id,app_types type,u32 &psize,u32 &csize)
+{
+    int size = FRAME_HEADER_SZ;
+
+    switch(id){
+    case APP_SPAN_NAME:
+        psize = SPAN_NAME_PAY_SZ;
+        csize = SPAN_NAME_CH_SZ;
+        break;
+    case APP_SPAN_PARAMS:
+        psize = SPAN_PARAMS_PAY_SZ;
+        csize = SPAN_PARAMS_CH_SZ;
+        break;
+    case APP_SPAN_CONF:
+        psize = SPAN_CONF_PAY_SZ;
+        csize = SPAN_CONF_CH_SZ;
+        break;
+    case APP_SPAN_STATUS:
+        psize = SPAN_STATUS_PAY_SZ;
+        csize = SPAN_STATUS_CH_SZ;
+        break;
+    case APP_INVENTORY:
+        psize = INVENTORY_PAY_SZ;
+        csize = INVENTORY_CH_SZ;
+        break;
+    case APP_ENDP_CONF:
+        psize = ENDP_CONF_PAY_SZ;
+        csize = ENDP_CONF_CH_SZ;
+        break;
+    case APP_ENDP_CUR:
+        psize = ENDP_CUR_PAY_SZ;
+        csize = ENDP_CUR_CH_SZ;
+        break;
+    case APP_ENDP_15MIN:
+        psize = ENDP_15MIN_PAY_SZ;
+        csize = ENDP_15MIN_CH_SZ;
+        break;
+    case APP_ENDP_1DAY:
+        psize = ENDP_1DAY_PAY_SZ;
+        csize = ENDP_1DAY_CH_SZ;
+        break;
+    case APP_ENDP_MAINT:
+        psize = ENDP_MAINT_PAY_SZ;
+        csize = ENDP_MAINT_CH_SZ;
+        break;
+    case APP_CPROF:
+		psize = CPROF_PAY_SZ;
+		csize = CPROF_CH_SZ;
+		break;
+    case APP_LIST_CPROF:
+		psize = CPROF_LIST_PAY_SZ;
+		csize = CPROF_LIST_CH_SZ;
+		break;
+    case APP_ADD_CPROF:
+		psize = CPROF_ADD_PAY_SZ;
+		csize = CPROF_ADD_CH_SZ;
+		break;
+    case APP_DEL_CPROF:
+		psize = CPROF_DEL_PAY_SZ;
+		csize = CPROF_DEL_CH_SZ;
+		break;
+    case APP_ADD_CHAN:
+		psize = CHAN_ADD_PAY_SZ;
+		csize = CHAN_ADD_CH_SZ;
+		break;
+    case APP_DEL_CHAN:
+		psize = CHAN_DEL_PAY_SZ;
+		csize = CHAN_DEL_CH_SZ;
+		break;
+    case APP_CHNG_CHAN:
+		psize = CHAN_CHNG_PAY_SZ;
+		csize = CHAN_CHNG_CH_SZ;
+		break;
+    case APP_LOOP_RCNTRST:
+		psize = LOOP_RCNTRST_PAY_SZ;
+		csize = LOOP_RCNTRST_CH_SZ;
+		break;
+    case APP_DUMP_CFG:
+		psize = DUMP_CFG_PAY_SZ;
+		csize = DUMP_CFG_CH_SZ;
+		break;
+	case APP_SENSORS:
+		psize = SENSORS_PAY_SZ;
+		csize = SENSORS_CH_SZ;
+		break;
+	case APP_SENSOR_FULL:
+		psize = SENSOR_FULL_PAY_SZ;
+		csize = SENSOR_FULL_CH_SZ;
+		break;
+    default:
+        return -1;
+    }
+
+    size += psize;
+    if( type == APP_SET ){
+        size += csize;
+    }else{
+        csize = 0;
+    }
+    return size;
+}
+
+const char *app_frame::
+chan_name(){
+	return hdr->dname;
+}
+
+void app_frame::
+chan_name(char *name)
+{
+    strncpy(hdr->dname,name,SPAN_NAME_LEN);
+}
+
+char *app_frame::
+payload_ptr(){
+    ASSERT( buf );
+    if( buf )
+		return &buf[FRAME_HEADER_SZ];
+    return NULL;
+}
+
+char * app_frame::
+changelist_ptr(){
+    ASSERT(buf && hdr->csize);
+    if( buf && hdr->csize )
+        return &buf[FRAME_HEADER_SZ + hdr->psize];
+    return NULL;
+}
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/comm.cpp net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/comm.cpp
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/comm.cpp	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/comm.cpp	2008-05-22 15:08:44.000000000 +0700
@@ -0,0 +1,83 @@
+#include <app-if/app_frame.h>
+#include <app-if/app_comm_cli.h>
+
+
+extern "C" {
+
+	app_comm_cli *
+	init_comm(int q)
+	{
+		app_comm_cli *cli = new app_comm_cli("/var/eocd/eocd-socket",q);
+		if( !cli->init_ok() ){
+			delete cli;
+			return NULL;
+		}
+		return cli;
+	}
+
+	char *
+	comm_alloc_request(app_ids id,app_types type,char *chname,app_frame **fr)
+	{
+		*fr = new app_frame(id,type,app_frame::REQUEST,1,chname);
+		if( !(*fr)->frame_ptr() ){
+			return NULL;
+		}
+		return (*fr)->payload_ptr();
+	}
+
+	app_frame *
+	comm_request(app_comm_cli *comm,app_frame *fr)
+	{
+		char *b;
+		app_frame *fr1 = NULL;
+		int i = 0;
+    
+		while(i<3){
+			comm->send(fr->frame_ptr(),fr->frame_size());
+			comm->wait();
+			int size = comm->recv(b);
+			if( size <=0 ){
+				i++;
+				continue;
+			}
+	    
+			fr1 = new app_frame(b,size);
+			if( !fr1->frame_ptr() ){
+				delete fr1;
+				fr1 = NULL;
+				i++;
+				continue;
+			}
+			if( fr1->is_negative() ){
+				delete fr1;
+				return NULL;
+			}
+			break;
+		}
+		return fr1;
+	}
+
+	char *
+	comm_frame_payload(app_frame *fr)
+	{
+		if( !fr->frame_ptr() )
+			return NULL;
+		return fr->payload_ptr();
+	}
+
+	void 
+	set_chan_name(app_frame *fr,char *name)
+	{
+		fr->chan_name(name);
+	}
+
+	void comm_frame_free(app_frame *fr){
+		delete fr;
+	}
+
+	void comm_free(app_comm_cli *cli){
+		delete cli;
+	}
+
+}
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/comm.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/comm.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/comm.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/comm.h	2008-05-22 15:08:44.000000000 +0700
@@ -0,0 +1,18 @@
+#ifndef SHDSL_COMM_H
+#define SHDSL_COMM_H
+
+#include <generic/EOC_types.h>
+#include <app-if/app_messages.h>
+
+struct app_comm;
+struct app_frame;
+
+struct app_comm *init_comm(int q);
+char *comm_alloc_request(app_ids id,app_types type,char *chname,struct app_frame **fr);
+struct app_frame *comm_request(struct app_comm *comm,struct app_frame *fr);
+char *comm_frame_payload(struct app_frame *fr);
+void set_chan_name(struct app_frame *fr,char *name);
+void comm_frame_free(struct app_frame *fr);
+void comm_free(struct app_comm *cli);
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/Makefile net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/Makefile
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/Makefile	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/Makefile	2008-12-19 16:11:32.000000000 +0600
@@ -0,0 +1,32 @@
+
+ifeq ($(TOPDIR),)
+    TOPDIR=$(PWD)/../
+#    CC=gcc
+#    CXX=g++
+#    AR=ar
+#    RANLIB=ranlib
+endif
+
+.PHONY: install lib objects apps
+
+all: lib install
+
+objects: app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o comm.o
+
+install: app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o
+	cp $^ $(TOPDIR)/build
+
+all: install  apps
+#	g++ $(CPPFLAGS) -o result main.cpp
+
+apps: install
+	make -C applications
+
+lib: objects
+	$(AR) rc libcomm.a app_comm.o app_comm_cli.o app_comm_srv.o app_frame.o comm.o
+	$(RANLIB) libcomm.a
+
+clean:
+	rm -f *.o *.lo
+	rm -f result libcomm.* ext cli srv
+	make -C applications clean
\ No newline at end of file
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/TODO.txt net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/TODO.txt
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/app-if/TODO.txt	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/app-if/TODO.txt	2009-06-27 07:52:20.000000000 +0700
@@ -0,0 +1 @@
+(+)1. Broken pipe problem
\ No newline at end of file
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_cli.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,18 @@
+#ifndef EOCD_APP_COMM_CLI_H
+#define EOCD_APP_COMM_CLI_H
+
+#include <app-if/app_comm.h>
+
+class app_comm_cli : public app_comm {
+protected:
+    int complete_wait();
+public:
+    app_comm_cli(char *sock_name,int quiet = 0);
+    ~app_comm_cli();
+    int send(char *buf,size_t size);
+    ssize_t recv(char *&buf);
+};
+
+#endif
+
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,63 @@
+#ifndef EOCD_APP_COMMUNICATOR_H
+#define EOCD_APP_COMMUNICATOR_H
+
+#include <sys/types.h>
+#include <string.h>
+#include <malloc.h>
+#include <stdio.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+class app_comm{
+protected:
+    enum { MAX_SOCK_NAME = 256 };
+    enum { BLOCK_SIZE = 1024 };
+    
+    int error_init;
+
+    char *sname;
+    int sfd;
+    fd_set socks;
+    int hisock;    
+    
+    int init_success(){ return !error_init; }
+    int set_nonblock(int sock);
+    virtual int build_select_list();
+    virtual int complete_wait() = 0;
+
+    // data transparency && message end/begin flags
+    char *transp(char *buf,size_t size,size_t &nsize){
+	nsize = size;
+	return buf;
+    }
+    char *untransp(char *frame,size_t frame_len){
+	return frame;
+    }
+public:
+    app_comm(char *sock_name){
+	sname = strndup(sock_name,MAX_SOCK_NAME);
+	error_init = 0;
+    }
+    app_comm(char *sock_path,char *sock_name){
+	int len = strnlen(sock_path,MAX_SOCK_NAME) + strnlen(sock_name,MAX_SOCK_NAME) + 2;
+	sname = (char*)malloc(sizeof(char) * len);
+	snprintf(sname,len,"%s/%s",sock_path,sock_name);
+	error_init = 0;
+    }
+    ~app_comm(){
+//	printf("Call destructor\n");
+	free(sname);
+    }
+    int wait(int sec = 4);
+    int _send(int fd,char *buf,size_t size);
+    ssize_t _recv(int fd,char *&buf);
+    int init_ok(){ return (!error_init); }
+};
+
+#endif
+
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_comm_srv.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,24 @@
+#ifndef EOC_APP_COMM_SRV_H
+#define EOC_APP_COMM_SRV_H
+
+#include <app-if/app_comm.h>
+
+class app_comm_srv : public app_comm {
+protected:
+    #define MAX_CONNECTIONS 5
+    int conn_fd[MAX_CONNECTIONS];
+    unsigned char conn_act[MAX_CONNECTIONS];
+    int conn_num;
+
+    // functions
+    int complete_wait();
+    int new_connection();
+    int build_select_list();
+    int next_fd();
+public:
+    app_comm_srv(char *sock_path,char *sock_name);
+    int send(int conn_num,char *buf,size_t size);
+    ssize_t recv(int &conn_idx,char *&buf);
+};
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_frame.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,64 @@
+#ifndef APP_FRAME_H
+#define APP_FRAME_H
+
+#include <stdio.h>
+#include <generic/EOC_types.h>
+#include <eoc_debug.h>
+#include <string.h>
+#include <time.h>
+
+#include <app-if/app_messages.h>
+
+#define APP_FRAME_DEBUG 0
+
+class app_frame{
+ public:
+    typedef enum { REQUEST,RESPONSE } roles;
+ protected:
+    typedef struct {
+		u32 len;
+		u32 psize;
+		u16 csize;
+		u8 id;
+		u8 type:2;
+		u8 role:1;
+		u8 error;
+		char dname[SPAN_NAME_LEN];
+		time_t tstamp;
+		u8 act_sec;
+    }app_frame_hdr;
+    
+    app_frame_hdr *hdr;
+    enum {FRAME_HEADER_SZ = sizeof(app_frame_hdr) };
+    char *buf;
+    u32 buf_size;
+    int size_by_id(app_ids id,app_types type,u32 &psize,u32 &csize);
+    
+ public:
+    app_frame(app_ids id,app_types type,roles role,u8 act_sec,char *dname = "\0");
+    app_frame(char *b,int size);
+    ~app_frame();
+    const char *chan_name();
+    void chan_name(char *name);
+    char *payload_ptr();
+    char *changelist_ptr();
+    char *frame_ptr(){ return buf; }
+    int frame_size(){ return buf_size; }
+    app_ids id(){ return (app_ids)hdr->id; }
+    app_types type(){ return (app_types)hdr->type; }
+    roles role(){ return (roles)hdr->role; }
+	void negative(){ hdr->error = 1; }
+	void negative(int errcode ){ hdr->error = errcode; }
+    int is_negative(){ return hdr->error; }
+    void response(){ hdr->role = RESPONSE; }
+    int info_uptodate(){
+		time_t cur;
+		if(time(&cur) < 0){
+			PDEBUG(DERR,"Error getting current time");
+		}
+		return ((cur-hdr->tstamp)<hdr->act_sec) ? 1 : 0;
+    }
+	
+};
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/app_messages.h	2009-06-27 08:11:41.000000000 +0700
@@ -0,0 +1,321 @@
+#ifndef APP_MESSAGES_H
+#define APP_MESSAGES_H
+
+#include <snmp/snmp-generic.h>
+#include <generic/span_conf_type.h>
+#include <generic/EOC_responses.h>
+#include <generic/EOC_types.h>
+//#include <devs/EOC_dev.h>
+typedef enum {
+	comp_base = 0, comp_ext1, comp_max
+} compatibility_t;
+			
+
+
+typedef enum { APP_SPAN_NAME=0,APP_SPAN_PARAMS,APP_SPAN_CONF,APP_SPAN_STATUS,
+			   APP_INVENTORY, APP_ENDP_CONF, APP_ENDP_CUR, APP_ENDP_15MIN,
+			   APP_ENDP_1DAY, APP_ENDP_MAINT, APP_UNIT_MAINT, APP_CPROF,
+			   APP_LIST_CPROF, APP_ADD_CPROF, APP_DEL_CPROF, APP_LOOP_RCNTRST,
+			   APP_ADD_CHAN, APP_DEL_CHAN, APP_CHNG_CHAN, APP_ENDP_APROF,
+			   APP_DUMP_CFG,APP_SENSORS,APP_SENSOR_FULL
+} app_ids;
+
+#define app_ids_num 23
+
+typedef enum { APP_SET,APP_GET,APP_GET_NEXT } app_types;
+
+/*
+1. список обслуживаемых каналов
+2. Для конкретного канала: число элементов в канале, число пар проводов
+*/
+
+#define SPAN_NAMES_NUM 4
+#define SPAN_NAME_LEN 32
+
+
+struct span_desc{
+    char name[SPAN_NAME_LEN];
+	dev_type t;
+	compatibility_t comp;
+};
+
+typedef struct{
+    u8 filled:7;
+    u8 last_msg:1;
+	struct span_desc spans[SPAN_NAMES_NUM];
+} span_name_payload;
+#define SPAN_NAME_PAY_SZ sizeof(span_name_payload)
+#define SPAN_NAME_CH_SZ 0
+
+typedef struct{
+    u8 units;
+    u8 link_establ:1;
+    u8 loops:7;
+} span_params_payload;
+#define SPAN_PARAMS_PAY_SZ sizeof(span_params_payload)
+#define SPAN_PARAMS_CH_SZ 0
+
+typedef struct{
+	dev_type type;
+    s16 nreps;
+    char conf_prof[SNMP_ADMIN_LEN+1];
+    char alarm_prof[SNMP_ADMIN_LEN+1];
+} span_conf_payload;
+#define SPAN_CONF_PAY_SZ sizeof(span_conf_payload)
+#define SPAN_CONF_CH_SZ 0
+
+typedef struct{
+    s8 nreps;
+    u32 max_lrate;
+    u32 act_lrate;
+    u8 region0 : 1;
+    u8 region1 : 1;
+    u8 : 6;
+    u32 max_prate;
+    u32 act_prate;
+	u8 tcpam;
+} span_status_payload;
+#define SPAN_STATUS_PAY_SZ sizeof(span_status_payload)
+#define SPAN_STATUS_CH_SZ 0
+
+typedef struct{
+    u8 unit;
+    u8 eoc_softw_ver;
+    resp_inventory inv;
+    u8 region0 :1;
+    u8 region1 :1;
+} inventory_payload;
+#define INVENTORY_PAY_SZ sizeof(inventory_payload)
+#define INVENTORY_CH_SZ 0
+
+typedef struct{
+    u8 unit;
+    u8 side;
+    u8 loop;
+    char alarm_prof[SNMP_ADMIN_LEN+1];
+} endp_conf_payload;
+#define ENDP_CONF_PAY_SZ sizeof(endp_conf_payload)
+// TODO: may be set request!
+#define ENDP_CONF_CH_SZ 0
+
+typedef struct {
+    u8 unit;
+    u8 side;
+    u8 loop;
+    s32 cur_attn;
+    s32 cur_snr;
+    shdsl_status_t cur_status;
+    counters_t total;
+    counters_t relative;
+	time_t relative_ts;
+    u32 cur_15m_elaps;
+    counters_t cur15min;
+    u32 cur_1d_elaps;
+    counters_t cur1day;
+    s32 CurrTipRingReversal;
+    s32 CurrActivationState;
+} endp_cur_payload;
+#define ENDP_CUR_PAY_SZ sizeof(endp_cur_payload)
+#define ENDP_CUR_CH_SZ sizeof(endp_cur_payload)
+
+typedef struct {
+    u8 unit;
+    u8 side;
+    u8 loop;
+    u32 int_num;
+    counters_t cntrs;
+} endp_int_payload;
+
+#define endp_15min_payload endp_int_payload
+#define ENDP_15MIN_PAY_SZ sizeof(endp_15min_payload)
+#define ENDP_15MIN_CH_SZ 0
+
+#define endp_1day_payload endp_int_payload
+#define ENDP_1DAY_PAY_SZ sizeof(endp_15min_payload)
+#define ENDP_1DAY_CH_SZ 0
+
+
+typedef struct{
+    u8 unit;
+    u8 side;
+    s32 LoopbackConfig;
+    s32 TipRingReversal;
+    s32 PowerBackOff;
+    s32 SoftRestart;
+} endp_maint_payload;
+#define ENDP_MAINT_PAY_SZ sizeof(endp_maint_payload)
+
+typedef struct{
+    u8 LoopbackConfig:1;
+    u8 PowerBackOff:1;
+    u8 SoftRestart:1;
+} endp_maint_changes;
+#define ENDP_MAINT_CH_SZ sizeof(endp_maint_changes)
+
+typedef struct{
+    s32 LoopbackTimeout;
+    s32 PowerSource;
+} unit_maint_payload;
+#define UNIT_MAINT_PAY_SZ sizeof(unit_maint_changes)
+
+typedef struct{
+    u8 LoopbackTimeout:1;
+} unit_maint_changes;
+#define UNIT_MAINT_CH_SZ sizeof(unit_maint_changes)
+
+//------- Span Configuration -------------//
+
+typedef struct{
+    char pname[SNMP_ADMIN_LEN+1];
+	u8 cap;
+} cprof_add_payload;
+#define CPROF_ADD_PAY_SZ sizeof(cprof_add_payload)
+#define CPROF_ADD_CH_SZ 0
+
+
+typedef struct{
+    char pname[SNMP_ADMIN_LEN+1];
+} cprof_del_payload;
+#define CPROF_DEL_PAY_SZ sizeof(cprof_del_payload)
+#define CPROF_DEL_CH_SZ 0
+
+
+typedef struct{
+    char pname[SNMP_ADMIN_LEN+1];
+    span_conf_profile_t conf;
+    compatibility_t comp;
+    u8 filled:7;
+	char names[SPAN_NAMES_NUM][SPAN_NAME_LEN];
+} cprof_payload;
+#define CPROF_PAY_SZ sizeof(cprof_payload)
+
+typedef struct{
+    u8 annex :1;
+    u8 wires :1;
+    u8 power :1;
+    u8 psd :1;
+    u8 clk:1;
+    u8 line_probe:1;
+    u8 remote_cfg:1;
+    u8 rate:1;
+    u8 tcpam:1;
+    s8 cur_marg_down:1;
+    s8 worst_marg_down:1;
+    s8 cur_marg_up:1;
+    s8 worst_marg_up:1;
+    u8 use_cur_down :1;
+    u8 use_worst_down :1;
+    u8 use_cur_up :1;
+    u8 use_worst_up :1;
+} cprof_changes;
+#define CPROF_CH_SZ sizeof(cprof_changes)
+
+
+#define PROF_NAMES_NUM 8
+typedef struct{
+    u8 filled:7;
+    u8 last_msg:1;
+    char pname[PROF_NAMES_NUM][SNMP_ADMIN_LEN+1];
+} cprof_list_payload;
+#define CPROF_LIST_PAY_SZ sizeof(cprof_list_payload)
+#define CPROF_LIST_CH_SZ 0
+
+//--------------- Endpoint Alarm -----------------//
+
+typedef struct{
+    char ProfileName[SNMP_ADMIN_LEN];
+    s32 ThreshLoopAttenuation;
+    s32 ThreshSNRMargin;
+    u32 ThreshES;
+    u32 ThreshSES;
+    u32 ThreshCRCanomalies;
+    u32 ThreshLOSWS;
+    u32 hdsl2ShdslEndpointThreshUAS;
+} endp_alarm_prof_payload;
+#define ENDP_ALARM_PROF_PAY_SZ sizeof(endp_alarm_prof_payload)
+
+typedef struct{
+    u8 ThreshLoopAttenuation:1;
+    u8 ThreshSNRMargin:1;
+    u8 ThreshES:1;
+    u8 ThreshSES:1;
+    u8 ThreshCRCanomalies:1;
+    u8 ThreshLOSWS:1;
+    u8 hdsl2ShdslEndpointThreshUAS:1;
+} endp_alarm_prof_changes;
+#define ENDP_ALARM_PROF_CH_SZ sizeof(endp_alarm_prof_changes)
+
+//----------- Regenerator Sensors ----------------//
+
+typedef struct{
+    u8 unit;
+    resp_sensor_state state;
+	u8 sens1,sens2,sens3;
+} sensors_payload;
+#define SENSORS_PAY_SZ sizeof(sensors_payload)
+#define SENSORS_CH_SZ 0
+
+#define MSG_SENS_EVENTS 10
+struct sens_event{
+	int index;
+	time_t start,end;
+	u16 cnt;
+};
+
+typedef struct{
+    u8 unit;
+    u32 num : 31;
+    u32 last : 1;
+    u32 index;
+    int cnt;
+    struct sens_event ev[MSG_SENS_EVENTS];
+    
+} sensor_full_payload;
+#define SENSOR_FULL_PAY_SZ sizeof(sensor_full_payload)
+#define SENSOR_FULL_CH_SZ 0
+
+//----------- Endpoint counters reset ------------//
+
+typedef struct{
+    u8 unit;
+    u8 side;
+	u8 loop;
+} loop_rcntrst_payload;
+#define LOOP_RCNTRST_PAY_SZ sizeof(loop_rcntrst_payload)
+#define LOOP_RCNTRST_CH_SZ 0
+
+//----------- Channel add/del/change -------------//
+
+typedef struct{
+	u8 master:1;
+}chan_add_payload;
+#define CHAN_ADD_PAY_SZ sizeof(chan_add_payload)
+#define CHAN_ADD_CH_SZ 0
+
+typedef struct{
+}chan_del_payload;
+#define CHAN_DEL_PAY_SZ sizeof(chan_del_payload)
+#define CHAN_DEL_CH_SZ 0
+
+typedef struct{
+	char cprof[SNMP_ADMIN_LEN];
+	u8 master:1;
+	u8 master_ch:1;
+	u8 rep_num:4;
+	u8 rep_num_ch:1;
+	u8 cprof_ch:1;
+	u8 apply_conf:1;
+	u8 apply_conf_ch:1;
+} chan_chng_payload;
+#define CHAN_CHNG_PAY_SZ sizeof(chan_chng_payload)
+#define CHAN_CHNG_CH_SZ 0
+
+// --------- Dump configuration -------------- //
+#define DUMP_CFG_PAY_SZ 1
+#define DUMP_CFG_CH_SZ 0
+
+
+#endif
+
+
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/err_codes.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/err_codes.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/err_codes.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/err_codes.h	2009-04-18 11:54:36.000000000 +0700
@@ -0,0 +1,25 @@
+#ifndef ERROR_CODES_H
+#define ERROR_CODES_H
+
+enum err_codes {
+	DEFERR = 1, // Default err code
+	ERTYPE, // Error in request type
+	ERCHEXIST, // Channel already exist
+	ERCHNEXIST, // Channel not existb
+	ERNOPROF, // Profile not exist
+	ERNOMEM, // Not enough memory
+	ERNODEV, // No such device (dslX)
+	ERPARAM, // Request parameters in wrong
+	ERPNEXIST, // Conf profile not exist
+	ERPEXIST, // Conf profile already exist
+	ERPBUSY, // Conf profile is in use
+	ERNODB, // Channel dont maintain SHDSL DB
+	ERUNEXP, // Unexpected error
+	ERNOELEM, // Requested unit not exist
+	ERPNCOMP, // Some settings of profile not compatible with devices
+	ERPRONLY, // Profile is read-only
+	ENIMPL, // Finction is not implemented
+	ERNOSENSOR, // Requested not existing sensor
+};
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/err_strings.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/err_strings.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/app-if/err_strings.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/app-if/err_strings.h	2009-04-18 11:55:01.000000000 +0700
@@ -0,0 +1,17 @@
+#ifndef ERROR_STRINGS_H
+#define ERROR_STRINGS_H
+#include <app-if/err_codes.h>
+
+static char *err_strings[] = { "", "Wrong type of request",
+	"Channel already exist", "Channel not exist",
+	"No onfiguration profiles aviliable", "No memory", "Cannot find device",
+	"Some of command parameters is wrong", "Configuration profile not exist",
+	"Configuration profile already exist", "Configuration profile is in use",
+	"Channel not maintain SHDSL data base", "Unexpected error",
+	"Requested element not exist",
+	"Some settings of profile not compatible with devices",
+	"Profile is read-only", "Finction is not implemented","Requested not existing sensor" };
+
+#define ERR_STR_SIZE sizeof(err_codes)
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/eoc_debug.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/eoc_debug.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/eoc_debug.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/eoc_debug.h	2009-02-08 12:30:36.000000000 +0600
@@ -0,0 +1,47 @@
+#ifndef EOC_DEBUG_H
+#define EOC_DEBUG_H
+
+#include <stdio.h>
+//#define EOC_DEBUG
+
+extern int debug_lev;
+
+#define DOFF -1
+#define DERR 0
+#define DINFO 5
+#define DFULL 10
+
+#ifdef EOC_DEBUG
+#	include <cassert>
+#	define ASSERT(x) assert(x)
+#   define PDEBUG(lev,fmt,args...)							\
+{ \
+	if( lev<=debug_lev ){ \
+		printf("%s(%s) : " fmt " \n",__FILE__,__FUNCTION__, ## args  ); \
+		fflush(stdout); \
+	} \
+}
+
+#   define PDEBUGL(lev,fmt,args...)							\
+	if( lev<=debug_lev )										\
+		printf(fmt,## args)
+
+
+#	define EDEBUG(lev,function)					\
+	if( lev<=debug_lev )						\
+		function
+
+#	define PERROR(fmt,args...) printf("eocd(%s) " fmt " : %s\n", __FUNCTION__, ##args,strerror(errno))
+
+#else
+#	define ASSERT(x)
+#	define PDEBUG(lev,fmt,args...)
+#	define EDEBUG(lev,function)
+#	define PERROR(fmt,args...)
+
+#endif
+
+
+#endif
+
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_generic.h	2009-02-18 12:48:25.000000000 +0600
@@ -0,0 +1,36 @@
+#ifndef SIGRAND_EOC_GENERIC_H
+#define SIGRAND_EOC_GENERIC_H
+
+#include <generic/EOC_types.h>
+
+typedef enum { master,slave,repeater } dev_type;
+typedef enum { eoc_Offline, eoc_Discovery, eoc_Online } shdsl_state;
+typedef enum {err =-1,unknown=0 ,stu_c,stu_r,sru1,sru2,sru3,sru4,sru5,sru6,
+			sru7,sru8,sru9,sru10,BCAST=0xf} unit;
+typedef enum { no_side=-1,net_side=0,cust_side } side;
+
+// SHDSL standard related
+#define MAX_LOOPS 4
+#define MAX_UNITS 10
+#define MAX_REPEATERS (MAX_UNITS-2)
+
+// EOC messages
+#define REQUEST_QUAN 128
+#define RESPONSE_QUAN 128
+#define RESP_OFFSET 128
+
+
+
+// OS related
+#define FNAME_SIZE 32
+#define PATH_SIZE 256
+#define FILE_PATH_SIZE PATH_SIZE+FNAME_SIZE
+#define IF_NAME_LEN 32
+#define PCI_NAME_LEN 32
+#define PCI_MAX_SLOTS 8
+#define MOD_MAX_DEVS 8
+#define DEVICE_PATH "/sys/bus/pci/devices"
+#define OS_IF_PATH "/sys/class/net"
+
+#endif
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_msg.h	2008-05-22 15:37:22.000000000 +0700
@@ -0,0 +1,54 @@
+#ifndef EOC_MSG_H
+#define EOC_MSG_H
+
+#include <stdio.h>
+#include <string.h>
+
+#include <generic/EOC_generic.h>
+
+class EOC_msg{
+public:
+    enum Direction { NOSTREAM,DOWNSTREAM, UPSTREAM };
+    enum EOC_CONSTS {EOC_HEADER=2};
+protected:
+    char *buf;
+    int size,bsize;
+	char *chname;
+    enum Direction dir;
+public:
+    EOC_msg();
+    EOC_msg(int size);    
+    EOC_msg(EOC_msg *ex);
+    EOC_msg(EOC_msg *ex,int new_size);    
+    ~EOC_msg();
+    void direction(enum Direction d);
+    Direction direction();
+    unsigned char type();
+    int type(unsigned char);
+    unit dst();
+    int dst(unit dst);
+    unit src();
+    int src(unit src);
+    int setup(char *ptr,int size);
+    void clean();
+    
+    inline char *mptr(){ return buf; }
+    inline int msize(){	return size; }
+    inline char *payload(){ return &buf[2]; }
+    inline int payload_sz(){ return size-2; }    
+    int response(int);
+    int resize(int sz);
+	inline void set_chname(char *n){ chname = n; }
+	inline char *get_chname(){ return chname; }
+    
+    // class of message
+    inline int is_request(){
+	if( type() < 127 )
+	    return 1;
+	return 0;
+    }
+    inline int is_response(){ return !is_request(); }
+	
+};
+#endif
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_requests.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,54 @@
+/*
+ * EOC_requests.h:
+ *	Contains structures of SHDSL EOC requests
+ */
+#ifndef EOC_REQUESTS_H
+#define EOC_REQUESTS_H
+
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+
+#define REQ_DISCOVERY 1
+typedef struct{
+    u8 hop;
+} req_discovery; 
+#define REQ_DISCOVERY_SZ sizeof(req_discovery)
+
+#define REQ_INVENTORY 2
+typedef struct{
+}req_inventory; 
+#define REQ_INVENTORY_SZ sizeof(req_inventory)
+
+#define REQ_CONFIGURE 3
+typedef struct{
+    u8 loop_attn:7;
+    u8 conf_type:1;
+    u8 :4;
+    u8 snr_marg:7;
+} req_configure;
+#define REQ_CONFIGURE_SZ sizeof(req_configure)
+
+#define REQ_STATUS 11
+typedef struct{
+} req_status;
+#define REQ_STATUS_SZ sizeof(req_status)
+
+#define REQ_FULL_STATUS 12
+typedef struct{
+} req_full_status;
+#define REQ_FULL_STATUS_SZ sizeof(req_full_status)
+
+
+#define REQ_SRST_BCKOFF 15
+typedef struct{
+    u8 ns_srst :1;
+    u8 ns_bckoff :1;
+    u8 :6;
+    u8 cs_srst :1;
+    u8 cs_bckoff :1;
+    u8 :6; 
+    
+} req_srst_bckoff;
+#define REQ_SRST_BCKOFF_SZ sizeof(req_srst_bckoff)
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_responses.h	2008-12-12 14:52:22.000000000 +0600
@@ -0,0 +1,127 @@
+/*
+ * EOC_responses.h:
+ *	Contains structures of SHDSL EOC responses
+ */
+
+#ifndef EOC_RESPONSES_H
+#define EOC_RESPONSES_H
+#include <generic/EOC_types.h>
+#include <generic/EOC_generic.h>
+#include <generic/EOC_requests.h>
+
+#define REQ2RESP(x) (x + RESP_OFFSET)
+#define RESP2REQ(x) (x - RESP_OFFSET)
+#define RESP_IND(x) (x - RESP_OFFSET-1)
+
+// DISCOVERY response
+typedef struct{
+    u8 hop;
+    u8 res1;
+    u8 vendor_id[8];
+    u8 eoc_softw_ver;
+    u8 shdsl_ver;
+    u8 fwd_loss:1;
+    u8 :7;
+} resp_discovery;
+#define RESP_DISCOVERY REQ2RESP(REQ_DISCOVERY)
+#define RESP_DISCOVERY_SZ sizeof(resp_discovery)
+
+// IVENTORY response
+typedef struct{
+    u8 shdsl_ver;
+    u8 ven_lst[4];
+    u8 ven_issue[3];
+    u8 softw_ver[7];
+    u8 unit_id_code[11];
+    u8 res1;
+    u8 ven_id[9];
+    u8 ven_model[14];
+    u8 ven_serial[14];
+    u8 other[14];
+} resp_inventory;
+
+typedef struct{
+    u8 shdsl_ver;
+    u8 ven_lst[3];
+    u8 ven_issue[2];
+    u8 softw_ver[6];
+    u8 unit_id_code[10];
+    u8 res1;
+    u8 ven_id[8];
+    u8 ven_model[12];
+    u8 ven_serial[12];
+    u8 other[12];
+} resp_inventory_1;
+
+#define RESP_INVENTORY REQ2RESP(REQ_INVENTORY)
+#define RESP_INVENTORY_SZ sizeof(resp_inventory)
+#define RESP_INVENTORY_SZ_1 sizeof(resp_inventory_1)
+
+
+// CONFIGURE response
+typedef struct{
+    u8 utc:1;
+    u8 :7;
+    u8 loop_attn;
+    u8 :4;
+    u8 snr_marg :4;
+} resp_configure;
+#define RESP_CONFIGURE REQ2RESP(REQ_CONFIGURE)
+#define RESP_CONFIGURE_SZ sizeof(resp_configure)
+
+// STATUS response
+typedef struct{
+    s8 ns_snr_marg;
+    s8 cs_snr_marg;
+    u8 loop_id;
+} resp_status;
+#define RESP_STATUS REQ2RESP(REQ_STATUS)
+#define RESP_STATUS_SZ sizeof(resp_status)
+
+// SIDE PERF STATUS response
+typedef struct{
+    u8 :1;
+    u8 losws_alarm :1;
+    u8 loop_attn_alarm:1;
+    u8 snr_marg_alarm :1;
+    u8 dc_cont_flt:1;
+    u8 dev_flt:1;
+    u8 pwr_bckoff_st:1;
+    u8 :1;
+    s8 snr_marg;
+    s8 loop_attn;
+    u8 es;
+    u8 ses;
+    u16 crc;
+    u8 losws;
+    u8 uas;
+    u8 pwr_bckoff_base_val:4;
+    u8 cntr_rst_stur:1;
+    u8 cntr_ovfl_stur:1;
+    u8 cntr_rst_stuc:1;
+    u8 cntr_ovfl_stuc:1;
+    u8 loop_id:3;
+    u8 :4;
+    u8 pwr_bkf_ext:1;
+}side_perf;
+#define SIDE_PERF_SZ sizeof(side_perf)
+typedef side_perf resp_cside_perf;
+typedef side_perf resp_nside_perf;
+#define RESP_NSIDE_PERF 140
+#define RESP_NSIDE_PERF_SZ sizeof(resp_cside_perf)
+#define RESP_CSIDE_PERF 141
+#define RESP_CSIDE_PERF_SZ sizeof(resp_cside_perf)
+
+#define RESP_MAINT_STAT 137
+/*TODO : Add structure */
+
+#define RESP_SENSOR_STATE 192
+typedef struct{
+    u8 sensor1 :1;
+    u8 sensor2 :1;
+    u8 sensor3 :1;
+    u8 :5; 
+} resp_sensor_state;
+#define RESP_SENSOR_STATE_SZ sizeof(resp_sensor_state)
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/EOC_types.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,36 @@
+#ifndef EOC_TYPES_H
+#define EOC_TYPES_H
+
+typedef unsigned char u8;
+typedef signed char s8;
+typedef unsigned short u16;
+typedef signed short s16;
+typedef unsigned int u32;
+typedef signed int s32;
+
+typedef struct{
+    u16 noDefect:1;
+    u16 powerBackoff:1;
+    u16 deviceFault:1;
+    u16 dcContFault:1;
+    u16 snrMargAlarm:1;
+    u16 loopAttnAlarm:1;
+    u16 loswFailAlarm:1;
+    u16 configInitFailure:1;
+    u16 protoInitFailure:1;
+    u16 noNeighborPresent:1;
+    u16 loopbackActive:1;
+} shdsl_status_t;
+ 
+
+typedef struct{
+	u32 mon_sec;
+    u32 es;
+    u32 ses;
+    u32 crc;
+    u32 losws;
+    u32 uas;
+} counters_t;
+
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/generic/span_conf_type.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,39 @@
+#ifndef SPAN_CONF_TYPE_H
+#define SPAN_CONF_TYPE_H
+
+#include <generic/EOC_types.h>
+
+typedef enum { err_annex=0,annex_a=1,annex_b } annex_t;
+typedef enum { twoWire = 1,fourWire,sixWire,eightWire } wires_t;      
+typedef enum { err_power=0,noPower = 1, powerFeed, wettingCurrent } power_t;
+typedef enum { symmetric = 1, asymmetric } psd_t;
+typedef enum { localClk = 1, networkClk, dataOrNetworkClk, dataClk } clk_t;
+typedef enum { disable = 1, enable } line_probe_t;
+typedef enum { disabled = 1, enabled } remote_cfg_t; 
+typedef enum { err_tcpam=0,tcpam4=1,tcpam8,tcpam16,tcpam32,tcpam64,tcpam128 } tcpam_t; 
+
+
+typedef struct{
+    annex_t annex;
+    wires_t wires;      
+    power_t power;
+    psd_t psd;    
+    clk_t clk;    
+    line_probe_t line_probe;
+    remote_cfg_t remote_cfg;
+	tcpam_t tcpam;
+    
+    u8 use_cur_down :1;                                                   
+    u8 use_worst_down :1;                                                  
+    u8 use_cur_up :1;                                                     
+    u8 use_worst_up :1;
+
+    u32 rate;
+
+    s32 cur_marg_down;
+    s32 worst_marg_down;
+    s32 cur_marg_up;
+    s32 worst_marg_up;
+} span_conf_profile_t;
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/include/snmp/snmp-generic.h	2008-05-22 15:08:23.000000000 +0700
@@ -0,0 +1,6 @@
+#ifndef EOC_SNMP_H
+#define EOC_SNMP_H
+
+#define SNMP_ADMIN_LEN 32
+
+#endif
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/shdsl.c net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/shdsl.c
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/shdsl.c	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/shdsl.c	2009-06-27 07:52:20.000000000 +0700
@@ -0,0 +1,1844 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <net-snmp/net-snmp-config.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/auto_nlist.h>
+
+#include <stdio.h>
+#include <time.h>
+
+#include "shdsl.h"
+#include "struct.h"
+#include "util_funcs.h"
+#include "../sysORTable.h"
+#include "../interfaces.h"
+
+#include <app-if/app_messages.h>
+
+//--------- DEBUG OUTPUT -----------------//
+
+
+//#define DEBUG_ON
+#define DERR 1
+#define DINFO 5
+#define DALL 10
+#define PDEBUG(flag,fmt,args...)
+#ifdef DEBUG_ON
+#       undef PDEBUG
+#       define PDEBUG(flag,fmt,args...) \
+		if( flag ) \
+			printf("%s: " fmt " \n",__FUNCTION__, ## args  )
+#endif
+
+
+//------- Global definitions -------------//
+#define CACHE_INT 0
+#define SHDSL_MAX_CHANNELS 30
+typedef struct{
+    struct timeval tv;
+    char name[SPAN_NAME_LEN];
+    int index;
+    int units;
+    int wires;
+} shdsl_channel_elem;
+
+typedef struct{
+    struct timeval tv;
+    span_conf_payload p;
+} shdsl_spanconf_elem;
+
+typedef struct{
+    struct timeval tv;
+    span_status_payload p;
+} shdsl_spanstatus_elem;
+
+/* typedef struct{ */
+/*     struct timeval tv; */
+/*     span_status_payload p; */
+/* } shdsl_spanstatus_elem; */
+
+
+
+// -------- Served channel names cache -------------//
+shdsl_channel_elem tbl[SHDSL_MAX_CHANNELS];
+int tbl_size;
+struct timeval tbl_tv = {0,0};
+int min_i = 0;
+
+// -------- Served channels span info -------------//
+shdsl_spanconf_elem *spanconf_tbl[SHDSL_MAX_CHANNELS];
+int spanconf_tbl_size;
+shdsl_spanstatus_elem *spanstatus_tbl[SHDSL_MAX_CHANNELS];
+int spanstatus_tbl_size;
+
+
+/*---- global vars ----*/
+struct app_comm *comm;
+char driver_dir_path[]="/root/snmp/";
+
+
+char interface_ind;
+int unit_index = 0;
+int endp_index = 0;
+int wire_index = 0;
+counters_t perf_int;
+
+//------- DEBUG ------------//
+void
+dbg_oid(char *comment,char *name, int length)
+{
+    DEBUGMSGTL(("mibII/shdsl", comment));
+    DEBUGMSGOID(("mibII/shdsl", name, length));
+    DEBUGMSG(("mibII/shdsl", "\n"));    
+}
+
+
+/*------------------------------ mib registration data -----------------------------------*/
+
+oid hdsl2Shdsl_variables_oid[] = { SNMP_OID_MIB2, 10, 48, 1 };
+struct variable3 shdsl_spanconf[] = {
+{ CONF_NREPS, ASN_GAUGE,RWRITE, var_SpanConfEntry, 3, {1,1,1} },
+{ CONF_PRFL, ASN_OCTET_STR, RWRITE, var_SpanConfEntry, 3, {1,1,2} },    
+{ CONF_ALARMPRFL, ASN_OCTET_STR, RWRITE, var_SpanConfEntry, 3, {1,1,3} },    
+};
+
+struct variable3 shdsl_spanstat[] = {
+{ STATUS_NAVAILREPS, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,1} },
+{ STATUS_MAXATTLRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,2} },    
+{ STATUS_ACTLRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,3} },    
+{ STATUS_TRNSMSNMODCUR, ASN_BIT_STR, RONLY, var_SpanStatusEntry, 3, {2,1,4} },
+{ STATUS_MAXATTPRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,5} },    
+{ STATUS_ACTPRATE, ASN_UNSIGNED, RONLY, var_SpanStatusEntry, 3, {2,1,6} },        
+};
+
+struct variable3 shdsl_inventory[] = {
+{INV_INDEX, ASN_INTEGER, NOACCESS, var_InventoryEntry, 3, {3,1,1}},
+{INV_VID, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,2}},    
+{INV_VMODELNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,3}},    
+{INV_VSERNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,4}},
+{INV_VEOCSV, ASN_INTEGER, RONLY, var_InventoryEntry, 3, {3,1,5}},    
+{INV_STANDARDV, ASN_INTEGER, RONLY, var_InventoryEntry, 3, {3,1,6}},    
+{INV_VLISTNUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,7}},        
+{INV_VISSUENUM, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,8}},    
+{INV_VSOFTWV,ASN_OCTET_STR , RONLY, var_InventoryEntry, 3, {3,1,9}},
+{INV_EQCODE, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,10}},    
+{INV_VOTHER, ASN_OCTET_STR, RONLY, var_InventoryEntry, 3, {3,1,11}},
+{INV_TRNSMODECPB, ASN_BIT_STR, RONLY, var_InventoryEntry, 3, {3,1,12}}    
+};
+
+/*
+  struct variable3 shdsl_endp_conf[] = {
+  {ENDP_CONF_PROF, ASN_OCTET_STR, RONLY, var_EndpointConfEntry, 3, {4,1,3}},    
+  };
+*/
+
+struct variable3 shdsl_endp_currstat[] = {
+{ ENDP_STAT_CUR_ATN, ASN_INTEGER, RONLY, var_EndpointCurrEntry, 3, {5,1,1} },
+{ ENDP_STAT_CUR_SNRMGN, ASN_INTEGER, RONLY, var_EndpointCurrEntry, 3, {5,1,2} },
+{ ENDP_STAT_CUR_STATUS,ASN_BIT_STR,RONLY, var_EndpointCurrEntry, 3, {5,1,3} },
+{ ENDP_STAT_CUR_ES,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,4} },
+{ ENDP_STAT_CUR_SES,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,5} },
+{ ENDP_STAT_CUR_CRC,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,6} },
+{ ENDP_STAT_CUR_LOSWS,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,7} },
+{ ENDP_STAT_CUR_UAS,ASN_COUNTER,RONLY, var_EndpointCurrEntry, 3, {5,1,8} },
+{ ENDP_STAT_CUR_15MEL,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,9} },
+{ ENDP_STAT_CUR_15M_ES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,10} },
+{ ENDP_STAT_CUR_15M_SES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,11} },
+{ ENDP_STAT_CUR_15M_CRC,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,12} },
+{ ENDP_STAT_CUR_15M_LOSWS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,13} },
+{ ENDP_STAT_CUR_15M_UAS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,14} },
+{ ENDP_STAT_CUR_1DEL,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,15} },
+{ ENDP_STAT_CUR_1D_ES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,16} },
+{ ENDP_STAT_CUR_1D_SES,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,17} },
+{ ENDP_STAT_CUR_1D_CRC,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,18} },
+{ ENDP_STAT_CUR_1D_LOSWS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,19} },
+{ ENDP_STAT_CUR_1D_UAS,ASN_UNSIGNED,RONLY, var_EndpointCurrEntry, 3, {5,1,20} },
+};
+
+struct variable3 shdsl_endp_15minstat[] = {
+{ ENDP_15M_INT,ASN_UNSIGNED,NOACCESS,var_15MinIntervalEntry,3,{6,1,1} },
+{ ENDP_15M_ES,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,2} },
+{ ENDP_15M_SES,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,3} },
+{ ENDP_15M_CRC,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,4} },
+{ ENDP_15M_LOSWS,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,5} },
+{ ENDP_15M_UAS,ASN_UNSIGNED,RONLY,var_15MinIntervalEntry,3,{6,1,6} },
+};
+
+struct variable3 shdsl_endp_1daystat[] = {
+{ ENDP_1D_INT,ASN_UNSIGNED,NOACCESS,var_1DayIntervalEntry,3,{7,1,1} },
+{ ENDP_1D_MONSECS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,2} },
+{ ENDP_1D_ES,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,3} },
+{ ENDP_1D_SES,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,4} },
+{ ENDP_1D_CRC,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,5} },
+{ ENDP_1D_LOSWS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,6} },
+{ ENDP_1D_UAS,ASN_UNSIGNED,RONLY,var_1DayIntervalEntry,3,{7,1,7} },
+};
+
+/*
+  struct variable3 shdsl_endp_maint[] = {
+  { ENDP_MAINT_LOOPBACK, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,1} },
+  { ENDP_MAINT_TIPRINGREV, ASN_INTEGER, RONLY, var_EndpointMaintEntry, 3, {8,1,2} },
+  { ENDP_MAINT_PWRBACKOFF, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,3} },
+  { ENDP_MAINT_SOFTRESTART, ASN_INTEGER, RWRITE, var_EndpointMaintEntry, 3, {8,1,4} },
+  };
+
+  struct variable3 shdsl_unit_maint[] = {
+  {UNIT_MAINT_LPB_TO, ASN_INTEGER, RWRITE, var_UnitMaintEntry, 3, {9,1,1}},
+  {UNIT_MAINT_PWR_SRC, ASN_INTEGER, RONLY, var_UnitMaintEntry, 3, {9,1,2}},
+  };
+*/
+
+struct variable3 shdsl_conf_prof[] = {
+{CONF_WIRE_IFACE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,2}},
+{CONF_MIN_LRATE, ASN_UNSIGNED, RWRITE, var_SpanConfProfEntry, 3, {10,1,3}},
+{CONF_MAX_LRATE, ASN_UNSIGNED, RWRITE, var_SpanConfProfEntry, 3, {10,1,4}},
+{CONF_PSD, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,5}},
+{CONF_TRNSM_MODE, ASN_BIT_STR, RWRITE, var_SpanConfProfEntry, 3, {10,1,6}},
+{CONF_REM_ENABLE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,7}},
+{CONF_PWR_FEED, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,8}},
+{CONF_CURR_DOWN, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,9}},
+{CONF_WORST_DOWN, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,10}},
+{CONF_CURR_UP, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,11}},
+{CONF_WORST_UP, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,12}},
+{CONF_USED_MARG, ASN_BIT_STR, RWRITE, var_SpanConfProfEntry, 3, {10,1,13}},
+{CONF_REF_CLK, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,14}},
+{CONF_LPROBE, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,15}},
+{CONF_ROW_ST, ASN_INTEGER, RWRITE, var_SpanConfProfEntry, 3, {10,1,16}},
+};
+
+
+
+
+void
+init_shdsl(void)
+{
+
+    comm = NULL;
+    memset(&perf_int,0,sizeof(perf_int));
+    memset(spanconf_tbl,0,sizeof(spanconf_tbl));
+    spanconf_tbl_size = 0;
+    memset(spanstatus_tbl,0,sizeof(spanstatus_tbl));
+    spanstatus_tbl_size = 0;
+    memset(tbl,0,sizeof(tbl));
+
+    /*
+     * register ourselves with the agent to handle our mib tree 
+     */
+    PDEBUG(0,"Register Span Conf");
+    REGISTER_MIB("mibII/hdsl2ShdslSpanConf", shdsl_spanconf, variable3,
+                 hdsl2Shdsl_variables_oid);
+				 
+    PDEBUG(0,"Register Span Status");
+    REGISTER_MIB("mibII/hdsl2shdslSpanStatus", shdsl_spanstat, variable3,
+                 hdsl2Shdsl_variables_oid);
+
+	PDEBUG(0,"Register Inventory");
+    REGISTER_MIB("mibII/hdsl2shdslInventory", shdsl_inventory, variable3,
+                 hdsl2Shdsl_variables_oid);
+
+	/*
+	  REGISTER_MIB("mibII/hdsl2shdslEndpointConf", shdsl_endp_conf, variable3,
+	  hdsl2Shdsl_variables_oid);
+	*/
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpointCurr",shdsl_endp_currstat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpoint15min",shdsl_endp_15minstat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+	REGISTER_MIB("mibII/hdsl2shdslEndpoint1day",shdsl_endp_1daystat, variable3,
+				 hdsl2Shdsl_variables_oid);
+
+	/*
+	  REGISTER_MIB("mibII/hdsl2shdslEndpointMaint", shdsl_endp_maint, variable3,
+	  hdsl2Shdsl_variables_oid);
+
+	  REGISTER_MIB("mibII/hdsl2shdslUnitMaint", shdsl_unit_maint, variable3,
+	  hdsl2Shdsl_variables_oid);
+	*/
+		
+	REGISTER_MIB("mibII/hdsl2shdslSpanConfProfile", shdsl_conf_prof, variable3,
+				 hdsl2Shdsl_variables_oid);
+	  
+    DEBUGMSGTL(("mibII/hdsl2Shdsl","register variables"));
+	PDEBUG(0,"Register finished");
+}
+
+/*
+ * header_dslIfIndex(...
+ * Arguments:
+ * vp     IN      - pointer to variable entry that points here
+ * name    IN/OUT  - IN/name requested, OUT/name found
+ * length  IN/OUT  - length of IN/OUT oid's 
+ * exact   IN      - TRUE if an exact match was requested
+ * var_len OUT     - length of variable or 0 if function returned
+ * write_method
+ */
+
+int
+ifname_to_index(char *Name, int Len)
+{
+    short ifIndex = 0;
+    char ifName[20];
+    char found = 0;
+    Interface_Scan_Init();
+    while ( Interface_Scan_Next(&ifIndex, ifName, NULL, NULL) ){
+		if( !strcmp(Name, ifName)){
+			found = 1;
+			break;
+		}
+    }
+    if( found )
+		return ifIndex;
+    return -1;
+}
+
+int
+chann_names()
+{
+    struct app_frame *fr1,*fr2;
+    span_name_payload *p;
+    int i;
+    char ifname[SPAN_NAME_LEN];
+    int index,len;
+    // caching
+    struct timeval tvcur;
+    char tverr = 0;
+
+    if( gettimeofday(&tvcur,NULL) )
+		tverr = 1;
+
+	PDEBUG(0,"----------------------- >");
+	// ---- DEBUG ----//
+   	struct timeval tv1,tv2;
+    gettimeofday(&tv1,NULL);
+	// ---- DEBUG ----//
+	
+    if( ((tvcur.tv_sec - tbl_tv.tv_sec) > CACHE_INT) || tverr ){
+
+        ifname[0] = 0;
+		tbl_size = 0;
+		p = (span_name_payload*)
+			comm_alloc_request(APP_SPAN_NAME,APP_GET,ifname,&fr1);
+
+		if( !p ){
+    	    DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+    	    return -1;
+		}
+    
+        do{
+			set_chan_name(fr1,ifname);
+			fr2 = comm_request(comm,fr1);
+
+			if( !fr2 ){
+				PDEBUG(0,"mibII/hdsl2Shdsl Reqest failed");
+				comm_frame_free(fr1);
+				return min_i;
+			}
+			p = (span_name_payload*)comm_frame_payload(fr2);
+			for(i=0;i<p->filled;i++){
+				len = strnlen(p->spans[i].name,SPAN_NAME_LEN);
+				if( (p->spans[i].t == slave) || 
+					(index = ifname_to_index(p->spans[i].name,len)) < 0 )
+					continue;
+
+				PDEBUG(0,"save name = %s",p->spans[i].name);
+				strncpy(tbl[tbl_size].name,p->spans[i].name,len);
+				tbl[tbl_size].index = index;
+				if( (tbl_size==0) || tbl[min_i].index > tbl[tbl_size].index  ){
+					min_i = tbl_size;
+				}
+				tbl[tbl_size].units = -1;
+				tbl[tbl_size].wires = -1;
+				tbl[tbl_size].tv.tv_sec = 0;
+				tbl_size++;
+			}
+			if( !p->last_msg && p->filled){
+				strncpy(ifname,p->spans[p->filled-1].name,SPAN_NAME_LEN);
+			}
+			comm_frame_free(fr2);
+		}while( tbl_size<SHDSL_MAX_CHANNELS && !p->last_msg );
+		
+		comm_frame_free(fr1);
+		tbl_tv = tvcur;
+    }
+			
+	//--- DEBUG ---//
+    gettimeofday(&tv2,NULL);
+	PDEBUG(0,"<------- %d ------------",tv2.tv_usec-tv1.tv_usec);
+	//--- DEBUG ---//
+
+    return min_i;
+}
+
+
+static int
+header_ifIndex(struct variable *vp,
+               oid * name, size_t * length, int exact,
+			   size_t * var_len, WriteMethod ** write_method)
+{
+    oid newname[MAX_OID_LEN];
+    int base_compare;
+    int oid_min = (vp->namelen > *length) ? *length : vp->namelen;
+    int min_ind = -1, min_i = 0;
+    int i;
+	// ---- DEBUG ----//
+   	struct timeval tv1,tv2;
+    gettimeofday(&tv1,NULL);
+	// ---- DEBUG ----//
+
+	PDEBUG(0,"---------------------->");
+    if( (min_i = chann_names()) < 0 ){
+		PDEBUG(0,"Cannot get table of controlling interfaces");
+		return MATCH_FAILED;
+    }
+	PDEBUG(0,"chan names-success. min_i=%d\n",min_i);
+
+    if( !tbl_size ){
+		PDEBUG(0,"MATCH FAILED: tbl_size is zero");
+		return MATCH_FAILED;
+    }
+
+    memcpy((char *) newname, (char *) vp->name,
+           (int) vp->namelen * sizeof(oid));
+
+    if( (base_compare = snmp_oid_compare(name,oid_min,newname,oid_min)) > 0){
+		return MATCH_FAILED;
+    }
+    
+    if( exact ){
+		if( base_compare || (*length < vp->namelen+1) ){
+			return MATCH_FAILED;
+		}
+		// check that name[vp->namelen] is DSL index
+		for(i=0;i<tbl_size;i++){
+			if( name[vp->namelen] == tbl[i].index ){
+				interface_ind = i;
+				break;
+			}
+		}
+		if( i == tbl_size )
+			return MATCH_FAILED;
+    } else {
+		// 1. OID for GETNEXT > vp base OID
+		// 2. Index of GETNEXT > max index
+		if( base_compare < 0 || ( !base_compare && *length<=vp->namelen) ){
+			memcpy((char*)name,(char*)newname,((int)vp->namelen+1)*sizeof(oid));
+			*length = vp->namelen + 1;
+			name[vp->namelen] = tbl[min_i].index;
+			interface_ind  = min_i;
+		}else if( !base_compare ){
+			min_i = 0;
+			min_ind = -1;
+			for( i=0;i<tbl_size;i++){
+				if( tbl[i].index > name[vp->namelen] ){
+					if( (min_ind < 0) || (min_ind > tbl[i].index) ){
+						min_i = i;
+						min_ind = tbl[i].index;
+					}
+				}
+			}
+			if( min_ind>0 ){
+				interface_ind = min_i;
+				name[vp->namelen] = tbl[min_i].index;
+			}else{
+				return MATCH_FAILED;
+			}
+		} else
+			return MATCH_FAILED;
+    }
+	
+    *write_method = 0;
+    *var_len = sizeof(long); 
+    dbg_oid("Result_oid ",name,*length);
+
+	//--- DEBUG ---//
+    gettimeofday(&tv2,NULL);
+	PDEBUG(0,"<------- %d ------------",tv2.tv_usec-tv1.tv_usec);
+	//--- DEBUG ---//
+    return name[vp->namelen];
+}
+
+
+/*
+ * Span Configuration Group 
+ */
+
+u_char *
+var_SpanConfEntry(struct variable * vp,
+				  oid * name,
+				  size_t * length,
+				  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_conf_payload *p;
+    static char ConfProfile[SNMP_ADMIN_LEN];
+    char *return_ptr = NULL;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+
+	PDEBUG(0,"--------------------->");
+    comm = init_comm();
+    if(!comm){
+        DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+        return NULL;
+    }
+
+    if ( ( iface=header_ifIndex(vp, name, length, exact, var_len,write_method) )
+         == MATCH_FAILED || (*length != vp->namelen+1)){
+		//	DEBUGMSG(("mibII/shdsl", "SpanConf: MATCH_FAILED\n"));	
+		//	printf("mibII/shdsl SpanConf: MATCH_FAILED\n");	
+		goto exit;
+    }
+
+    if( gettimeofday(&tvcur,NULL) ){
+		PDEBUG(0,"tverr occured");
+		tverr = 1;
+    }
+
+    if( !spanconf_tbl[interface_ind] || tverr ||
+		(tvcur.tv_sec - spanconf_tbl[interface_ind]->tv.tv_sec > CACHE_INT) ){
+
+        p = (span_conf_payload*)comm_alloc_request(APP_SPAN_CONF,APP_GET,tbl[interface_ind].name,&fr1);
+		if( !p ){
+			//DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			PDEBUG(0,"mibII/shdsl Cannot allocate application frame");
+    	    goto exit;
+		}
+
+		fr2 = comm_request(comm,fr1);
+        if( !fr2 ){
+			PDEBUG(0,"Error requesting");
+    	    goto exit;
+		}
+		p = (span_conf_payload*)comm_frame_payload(fr2);
+
+        // Cache data
+		if( !spanconf_tbl[interface_ind] )
+			spanconf_tbl[interface_ind] = malloc(sizeof(shdsl_spanconf_elem));
+		spanconf_tbl[interface_ind]->p = *p;
+		spanconf_tbl[interface_ind]->tv = tvcur;
+    }else{
+		p = &spanconf_tbl[interface_ind]->p;
+    }
+
+    switch (vp->magic) {
+    case CONF_NREPS:
+		*var_len=sizeof(int);
+		long_return=p->nreps;
+		//	long_return= 2;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case CONF_PRFL:
+		strncpy(ConfProfile,p->conf_prof,SNMP_ADMIN_LEN);
+		//	strncpy(ConfProfile,"profile",SNMP_ADMIN_LEN);
+		*var_len=strnlen(ConfProfile,SNMP_ADMIN_LEN);
+		return_ptr = (u_char *)ConfProfile;	
+		break;
+    case CONF_ALARMPRFL:
+		goto exit;
+		//!!	*var_len=strlen(ConfAlarmProfile);
+		//!!	return (u_char *)ConfAlarmProfile;	
+    default:
+		break;
+    }
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+
+	PDEBUG(0,"< -------------------");
+    return return_ptr;
+}
+
+
+/*
+ * Span Status Group 
+ */
+
+u_char *
+var_SpanStatusEntry(struct variable * vp,
+					oid * name,
+					size_t * length,
+					int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+
+    span_status_payload *p;
+    char *return_ptr = NULL;
+    // Cacheing 
+    int tverr = 0;
+    struct timeval tvcur;
+
+	PDEBUG(0,"--------------------- >");
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( ( iface=header_ifIndex(vp, name, length, exact, var_len,write_method) )
+	     == MATCH_FAILED || (*length != vp->namelen+1)){
+		PDEBUG(0,"mibII/shdsl SpanConf: MATCH_FAILED");	
+        goto exit;
+    }
+
+    if( gettimeofday(&tvcur,NULL) ){
+		PDEBUG(0,"tverr occured");
+		tverr = 1;
+    }
+
+    if( !spanstatus_tbl[interface_ind] || tverr ||
+	    ((tvcur.tv_sec - spanstatus_tbl[interface_ind]->tv.tv_sec)>CACHE_INT) ){
+        p = (span_status_payload*)comm_alloc_request(APP_SPAN_STATUS,APP_GET,tbl[interface_ind].name,&fr1);
+		if( !p ){
+			//DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			PDEBUG(0,"Cannot allocate application frame");
+			goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+		if( !fr2 ){
+			PDEBUG(0,"Error requesting");
+			goto exit;
+		}
+		p = (span_status_payload*)comm_frame_payload(fr2);
+        // Cache data
+		if( !spanstatus_tbl[interface_ind] )
+			spanstatus_tbl[interface_ind] = malloc(sizeof(shdsl_spanstatus_elem));
+	
+		spanstatus_tbl[interface_ind]->p = *p;
+        spanstatus_tbl[interface_ind]->tv = tvcur;
+    }else{
+		p = &spanstatus_tbl[interface_ind]->p;
+    }
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case STATUS_NAVAILREPS:
+		long_return= p->nreps;    
+		if( p->nreps <0 )
+			long_return = 0;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_MAXATTLRATE:
+		long_return = p->max_lrate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_ACTLRATE:
+		long_return = p->act_lrate;
+		return_ptr = (u_char *) & long_return;
+		break;
+		/*    case STATUS_TRNSMSNMODCUR:
+		//	long_return = *((unsigned char*)&cfg.annex);
+		*var_len = sizeof(char);
+		return (u_char *)&long_return;
+		*/
+	case STATUS_MAXATTPRATE:
+		long_return = p->max_prate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    case STATUS_ACTPRATE:
+		long_return = p->act_prate;
+		return_ptr = (u_char *) & long_return;
+		break;
+    default:
+		break;
+    }
+   
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+	PDEBUG(0,"< -------------------");
+    return return_ptr;
+}
+
+
+/*
+ * Unit Inventory Group
+ */
+
+static int
+header_unitIndex(struct variable *vp,
+				 oid * name,
+				 size_t * length,
+				 int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int iface = 0;
+    int length_bkp = *length;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_params_payload *p;
+    int ret_val = MATCH_FAILED;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+	// ---- DEBUG ----//
+   	struct timeval tv1,tv2;
+    gettimeofday(&tv1,NULL);
+	PDEBUG(0,"--------------------- >");
+	// ---- DEBUG ----//
+
+	// If OID is belong to Inventory Table
+    if( (iface = header_ifIndex(vp, name, length,1/*exact = 1*/, var_len,write_method)) 
+	    != MATCH_FAILED ){ 	// OID belongs to Invetory table and ifIdex is valid
+		PDEBUG(0,"OID belong to Inv Table, interface_ind=%d,if = %s\n",interface_ind,
+				tbl[interface_ind].name);
+        
+		if( gettimeofday(&tvcur,NULL) ){
+			PDEBUG(0,"tverr occured");
+			tverr = 1;
+		}
+
+		if( ((tvcur.tv_sec - tbl[interface_ind].tv.tv_sec) > CACHE_INT) || tverr || 
+			tbl[interface_ind].units < 0 ){
+			p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+														 APP_GET,tbl[interface_ind].name,&fr1);
+			PDEBUG(0,"Refresh span params");
+
+			if( !p ){
+				PDEBUG(0,"ERROR: Cannot allocate application frame");
+				goto exit;
+			}
+			fr2 = comm_request(comm,fr1);
+			if( !fr2 ){
+				PDEBUG(0,"ERROR: Error requesting\n");
+				goto exit;
+			}
+			p = (span_params_payload*)comm_frame_payload(fr2);
+			// Cache data
+			tbl[interface_ind].tv = tvcur;
+			tbl[interface_ind].units = p->units;
+			tbl[interface_ind].wires = p->loops;
+
+			PDEBUG(0,"NEW %s params: units=%d, loop=%d",tbl[interface_ind].name,p->units,p->loops);
+		}
+		PDEBUG(0,"Get params info for %s: units(%d) loops(%d)",tbl[interface_ind].name,tbl[interface_ind].units,
+				tbl[interface_ind].wires);
+
+		if( exact ){ // Need exact MATCH
+			//	    printf("unitIndex: Exact match\n");
+			if( (*length >= vp->namelen+2) && 
+				(name[vp->namelen+1] > 0) && 
+				(name[vp->namelen+1]<= tbl[interface_ind].units) ){
+				//		    printf("unitIndex: Exact match - OK\n");
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			} else {
+				//		printf("unitIndex: Exact match - FAIL\n");
+				goto exit;
+			}
+		} else { // Need next regenerator index
+			if( *length >= vp->namelen+2 &&
+				(name[vp->namelen+1]+1 > 0) &&
+				(name[vp->namelen+1]+1 <= tbl[interface_ind].units) ){
+				//		printf("unitIndex: Next unit after %d\n",name[vp->namelen+1]);
+				name[vp->namelen+1]++;
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			}else if( *length == vp->namelen + 1 ){
+				name[vp->namelen+1] = stu_c;
+				//		printf("unitIndex:  First unit \n");
+				*length = vp->namelen+2;
+				ret_val = name[vp->namelen+1];
+				goto exit;
+			}
+		}
+    }
+    
+    if( exact ){
+		PDEBUG(0,"Exact match - seems failed");
+		goto exit;
+    }
+    
+    if( (iface=header_ifIndex(vp, name, length, exact, var_len,write_method)) 
+		== MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		PDEBUG(0,"Search for next iface failed");
+		goto exit;
+    }
+    
+    if( fr2 ){
+		comm_frame_free(fr2);
+		fr2 = NULL;
+    }
+
+    if( ((tvcur.tv_sec - tbl[interface_ind].tv.tv_sec) > CACHE_INT) || tverr || 
+		tbl[interface_ind].units < 0 ){
+	
+		if( !fr1 ){	
+			p = (span_params_payload*)comm_alloc_request(APP_SPAN_PARAMS,
+														 APP_GET,tbl[interface_ind].name,&fr1);
+		}else{
+			p = (span_params_payload*)comm_frame_payload(fr1);
+		}
+		    
+		if( !p ){
+			PDEBUG(0,"Cannot allocate application frame");
+    	    goto exit;
+		}
+		fr2 = comm_request(comm,fr1);
+		if( !fr2 ){
+			PDEBUG(0,"Error requesting");
+    	    goto exit;
+		}
+		p = (span_params_payload*)comm_frame_payload(fr2);
+
+		PDEBUG(0,"Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);    
+
+		tbl[interface_ind].units = p->units;
+		tbl[interface_ind].wires = p->loops;
+		tbl[interface_ind].tv = tvcur;
+    }
+	
+    name[vp->namelen+1] = stu_c;
+    *length = vp->namelen + 2;
+	PDEBUG(0,"Result: unit #%d\n",name[vp->namelen+1]);
+    ret_val = name[vp->namelen+1];
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+
+	//--- DEBUG ---//
+    gettimeofday(&tv2,NULL);
+	PDEBUG(0,"<------- %d ------------",tv2.tv_usec-tv1.tv_usec);
+	//--- DEBUG ---//
+    return ret_val;
+}
+
+
+u_char *
+var_InventoryEntry(struct variable * vp,
+				   oid * name,
+				   size_t * length,
+				   int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    int unit;
+    size_t length1;
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    inventory_payload *p;
+    resp_inventory *resp;
+    char *return_ptr = NULL;
+
+
+	PDEBUG(0,"------------------------>");
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( ( unit = header_unitIndex(vp,name,length,exact,var_len,write_method) )
+		 == MATCH_FAILED ){
+		PDEBUG(0,"Cannot find unit");
+		goto exit;
+    }
+
+	// ------------- Need cacheing ------------------//
+	p = (inventory_payload*)comm_alloc_request(APP_INVENTORY,APP_GET,
+											   tbl[interface_ind].name,&fr1);
+	if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		PDEBUG(0,"Cannot allocate application frame");
+		goto exit;
+	}
+
+	p->unit = unit;
+	fr2 = comm_request(comm,fr1);
+	if( !fr2 && exact ){
+		PDEBUG(0,"Error requesting");
+		goto exit;
+	}
+    
+	while( !fr2 ){
+		
+		if ( ( unit = header_unitIndex(vp,name,length,exact,var_len,write_method) )
+			 == MATCH_FAILED ){
+			PDEBUG(0,"Cannot find unit");
+			goto exit;
+		}
+
+		p = (inventory_payload*)comm_alloc_request(APP_INVENTORY,APP_GET,
+												   tbl[interface_ind].name,&fr1);
+		if( !p ){
+			DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+			PDEBUG(0,"Cannot allocate application frame");
+			goto exit;
+		}
+		p->unit = unit;
+		if( fr2 )
+			comm_frame_free(fr2);
+		fr2 = comm_request(comm,fr1);
+	}
+    
+	if( !fr2 ){
+		PDEBUG(0,"Error requesting");
+		goto exit;
+	}
+	p = (inventory_payload*)comm_frame_payload(fr2);
+	//~~~~~~~~~~~~~~~~~~ Need cacheing ~~~~~~~~~~~~~~~~~~~~~~~~`//
+
+	resp = &p->inv;
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case INV_VID:
+		*var_len = sizeof(resp->ven_id);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_id,*var_len);    
+		/* 		strncpy(return_buf,"111",10); */
+		/* 		*var_len = strlen(return_buf); */
+		return_ptr = (u_char *)return_buf;
+		break;
+    case INV_VMODELNUM:
+		*var_len = sizeof(resp->ven_model);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_model,*var_len);    
+		/* 		strncpy(return_buf,"222",10); */
+		/* 		*var_len = strlen(return_buf); */
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VSERNUM:
+		*var_len = sizeof(resp->ven_serial);
+		memset(return_buf,0,*var_len);
+		strncpy(return_buf,resp->ven_serial,*var_len);    
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VEOCSV:
+		long_return=p->eoc_softw_ver;
+		return_ptr = (u_char *)&long_return;
+		break;
+	case INV_STANDARDV:
+		long_return = resp->shdsl_ver;
+		return_ptr = (u_char *)&long_return;
+		break;
+	case INV_VLISTNUM:
+		*var_len = strlen(resp->ven_lst);
+		strncpy(return_buf,resp->ven_lst,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VISSUENUM:
+		*var_len = strlen(resp->ven_issue);
+		strncpy(return_buf,resp->ven_issue,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VSOFTWV:
+		*var_len = strlen(resp->softw_ver);
+		strncpy(return_buf,resp->softw_ver,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_EQCODE:
+		*var_len = strlen(resp->unit_id_code);
+		strncpy(return_buf,resp->unit_id_code,*var_len);
+		return_ptr = (u_char *)return_buf;
+		break;
+	case INV_VOTHER:
+		*var_len = strlen(resp->other);
+		strncpy(return_buf,resp->other,*var_len);    
+		return_ptr = (u_char *)return_buf;
+		break;
+		/*    case INV_TRNSMODECPB:
+		 *var_len = sizeof(info->TransModeCpb);
+		 long_return=info->TransModeCpb;
+		 return (u_char *)&long_return;
+		*/
+	}
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+	PDEBUG(0,"<------------------------");
+    return return_ptr;
+}
+
+/*
+ * ------------ Segment Endpoint Group --------------------
+ */
+ 
+ 
+/*
+ * header_endpIndex:
+ * 	Defines propriate endpoint index for incoming OID
+ */
+
+static int 
+header_endpIndex(struct variable *vp,
+				 oid * name,
+				 size_t * length,
+				 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int unit = 0;
+    int length_bkp = *length;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+
+	// ---- DEBUG ----//
+   	struct timeval tv1,tv2;
+    gettimeofday(&tv1,NULL);
+	PDEBUG(0,"--------------------- >");
+	// ---- DEBUG ----//
+
+    if ( ( unit = header_unitIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+		unit_index = unit;
+	    PDEBUG(0,"Result : if(%s) unit(%d)",tbl[interface_ind].name,unit_index);
+
+		if( exact ){ // Need exact MATCH
+			if( (*length >= vp->namelen+3) ){
+				switch( unit ){
+				case stu_c:
+					if( name[vp->namelen+2] != (cust_side+1) )
+						return MATCH_FAILED;
+					else
+						return name[vp->namelen+2];
+					break;
+				case stu_r:
+					if( name[vp->namelen+2] != (net_side+1) )		
+						return MATCH_FAILED;
+					else
+						return name[vp->namelen+2];
+					break;
+				case sru1:
+				case sru2:
+				case sru3:
+				case sru4:
+				case sru5:
+				case sru6:
+				case sru7:
+				case sru8:
+					if( name[vp->namelen+2] == (cust_side+1) || 
+						name[vp->namelen+2] == (net_side+1) )
+						return name[vp->namelen+2];
+					else
+						return MATCH_FAILED;
+				default:
+					return MATCH_FAILED;
+				}
+			} else
+				return MATCH_FAILED;
+		} else { // Nonexact match
+
+			PDEBUG(0,"nonexact match: unit(%d) side(%d)\n",unit,name[vp->namelen+2]);
+			if( unit >= sru1 && unit <=sru8 ){
+				if( *length >= vp->namelen+3 ){
+					if( name[vp->namelen+2] == (net_side+1) ){
+						name[vp->namelen+2] = (cust_side+1);
+						return name[vp->namelen+2];
+					}
+				}else if( *length == vp->namelen+2 ){
+					name[vp->namelen+2] == (net_side+1);
+					*length = vp->namelen+3;
+					return name[vp->namelen+2];	
+				}
+			}
+		}
+    }
+	
+    // OID does not belong to Inventory Table OR NO next regenerator 
+    if( exact ){
+		return MATCH_FAILED;
+    }
+	//    printf("endpIndex: SWITCH to next unit\n");
+    if( (unit=header_unitIndex(vp, name, length, exact, var_len,write_method)) 
+	    == MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		return MATCH_FAILED;
+    }
+    unit_index = unit;
+	PDEBUG(0,"NEXT Result : if(%s) unit(%d)",tbl[interface_ind].name,unit_index);
+
+    switch( unit ){
+    case stu_c:
+		name[vp->namelen+2] = (cust_side+1);
+		break;
+    case stu_r:
+		name[vp->namelen+2] = (net_side+1);    
+		break;
+    case sru1:
+    case sru2:
+    case sru3:
+    case sru4:
+    case sru5:
+    case sru6:
+    case sru7:
+    case sru8:
+		name[vp->namelen+2] = (net_side+1);
+		break;
+    default:
+		return MATCH_FAILED;
+    }
+    *length = vp->namelen + 3;
+
+	//--- DEBUG ---//
+    gettimeofday(&tv2,NULL);
+	PDEBUG(0,"<------- %d ------------",tv2.tv_usec-tv1.tv_usec);
+	//--- DEBUG ---//
+    return name[vp->namelen+2];
+}
+
+
+/*
+ * header_wirePairIndex:
+ * 	Defines propriate Wire pair index for incoming OID
+ *	(by now only 1 pair supported)
+ */
+
+static int 
+header_wirePairIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int endp = 0;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    span_params_payload *p;
+    int ret_val = MATCH_FAILED;
+    // Cacheing
+    struct timeval tvcur;
+    int tverr = 0;
+
+	// ---- DEBUG ----//
+   	struct timeval tv1,tv2;
+    gettimeofday(&tv1,NULL);
+	PDEBUG(0,"--------------------- >");
+	// ---- DEBUG ----//
+
+    if ( ( endp = header_endpIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+		endp_index = endp;
+		int k = tbl[interface_ind].wires;
+		PDEBUG(0,"Result : if(%s) unit(%d) endp(%d)",tbl[interface_ind].name,unit_index,endp_index);
+
+		if( exact ){ // Need exact MATCH
+			PDEBUG(0,"Exact Match");
+			if( (*length >= vp->namelen+4) && 
+				(name[vp->namelen+3] > 0) && (name[vp->namelen+3] <= tbl[interface_ind].wires) ){
+				ret_val =  name[vp->namelen+3];
+				goto exit;
+			} else {
+				goto exit;
+			}
+		} else { // Nonexact match
+			// Because we have only one wire pair - we change it only 
+			// if field is empty
+			if( *length == vp->namelen+3 ){
+				name[vp->namelen+3] = 1; // first pair
+				*length = vp->namelen+4;
+				ret_val = name[vp->namelen+3];
+				goto exit;
+			}else{
+				if( name[vp->namelen+3] <= 0 )
+					goto exit;
+				if( name[vp->namelen+3]+1 <= tbl[interface_ind].wires ){
+					*length = vp->namelen+4;
+					ret_val = (++name[vp->namelen+3]);
+					goto exit;
+				}
+			}
+		}
+    }
+	
+	PDEBUG(0,"Exact match failed");
+    if( exact ){
+		goto exit;
+    }
+    
+    if( (endp = header_endpIndex(vp, name, length, exact, var_len,write_method)) 
+	    == MATCH_FAILED ){ // No next interface or In OID is lager than Inventory Table OIDs
+		goto exit;
+    }
+    endp_index = endp;
+	PDEBUG(0,"NEXT Result : if(%s) unit(%d) endp(%d)",tbl[interface_ind].name,unit_index,endp_index);
+    name[ vp->namelen+3] = 1; // First pair
+    *length = vp->namelen + 4;
+    ret_val = name[vp->namelen+3];
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+
+	//--- DEBUG ---//
+    gettimeofday(&tv2,NULL);
+	PDEBUG(0,"<------- %d ------------",tv2.tv_usec-tv1.tv_usec);
+	//--- DEBUG ---//
+    return ret_val;
+}
+
+
+/*
+ * Segment Endpoint Current Status/Performance Group
+ */
+
+u_char *
+var_EndpointCurrEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    endp_cur_payload *p;
+    char *return_ptr = NULL;
+    int pair,endp;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    PDEBUG(0,"-----!!!!!!!!!!!!!!-------->");
+
+	// ------------------------------ Obtain requested information ------------------------------- //
+
+    if ( ( pair = header_wirePairIndex(vp,name,length,exact,var_len,write_method) )
+		 == MATCH_FAILED )
+        goto exit;
+       
+    PDEBUG(0,"Result : if(%s) unit(%d) side(%d) pair(%d)",tbl[interface_ind].name,unit_index,endp_index,pair);
+
+    p = (endp_cur_payload*)comm_alloc_request(APP_ENDP_CUR,APP_GET,
+											  tbl[interface_ind].name,&fr1);
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		PDEBUG(0,"var_InventoryEntry: Cannot allocate application frame");
+		goto exit;
+    }
+    p->unit = unit_index;
+    p->side = endp_index-1;
+    p->loop = pair-1;
+    fr2 = comm_request(comm,fr1);
+    PDEBUG(0,"Request if(%s) unit(%d) side(%d) loop(%d)",
+		   tbl[interface_ind].name,p->unit,p->side,p->loop);
+    
+    if( !fr2 && exact ){
+		PDEBUG(0,"var_InventoryEntry: error requesting");
+		goto exit;
+    }
+    
+    while( !fr2 ){
+		if ( ( pair = header_wirePairIndex(vp,name,length,exact,var_len,write_method) )
+			 == MATCH_FAILED )
+    	    goto exit;
+    
+		PDEBUG(0,"Result (rep): if(%s) unit(%d) side(%d) pair(%d)",tbl[interface_ind].name,unit_index,endp_index,pair);
+		set_chan_name(fr1,tbl[interface_ind].name);
+		p->unit = unit_index;
+		p->side = endp_index-1;
+		p->loop = pair-1;
+		fr2 = comm_request(comm,fr1);
+
+		PDEBUG(0,"Request (rep): if(%s) unit(%d) side(%d) loop(%d)",
+			   tbl[interface_ind].name,p->unit,p->side,p->loop);
+
+    }
+
+    if( !fr2 ){
+		PDEBUG(0,"error requesting");
+		goto exit;
+    }
+    
+    p = (endp_cur_payload*)comm_frame_payload(fr2);
+    
+	// ------------------------------ Return requested information ------------------------------- //
+	
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_STAT_CUR_ATN:
+		long_return = p->cur_attn;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_SNRMGN:
+		long_return = p->cur_snr;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_STATUS:
+		break;
+    case ENDP_STAT_CUR_ES:
+		long_return = (u_long)p->total.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_SES:
+		long_return = (u_long)p->total.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_CRC:
+		long_return = (u_long)p->total.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_LOSWS:
+		long_return = (u_long)p->total.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_UAS:
+		long_return = (u_long)p->total.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15MEL:
+		long_return = p->cur_15m_elaps;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_ES:
+		long_return = p->cur15min.es;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_SES:
+		long_return = p->cur15min.ses;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_CRC:
+		long_return = p->cur15min.crc;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_LOSWS:
+		long_return = p->cur15min.losws;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_15M_UAS:
+		long_return = p->cur15min.uas;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1DEL:
+		long_return = p->cur_1d_elaps;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_ES:
+		long_return = p->cur1day.es;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_SES:
+		long_return = p->cur1day.ses;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_CRC:
+		long_return = p->cur1day.crc;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_LOSWS:
+		long_return = p->cur1day.losws;
+		return_ptr = (char*)&long_return;
+		break;
+    case ENDP_STAT_CUR_1D_UAS:
+		long_return = p->cur1day.uas;
+		return_ptr = (char*)&long_return;
+		break;
+    default:
+		break;
+    }
+
+
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    comm_free(comm);
+    comm = NULL;
+    PDEBUG(0,"<------------!!!!!!!!!!!!!1----------\n\n");
+    return return_ptr;
+}
+
+// ----------------- Perfomance/Status intervals ------------------//
+
+static int 
+header_intervalIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method,app_ids msg_id)
+{
+    int wire = 0;
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1=NULL,*fr2=NULL;
+    endp_int_payload *p;
+    int int_num,ret_val = MATCH_FAILED;
+    
+    
+    PDEBUG(0,"(Input) if(%d) unit(%d) side(%d) pair(%d) int(%d) id(%d)",
+		   __FUNCTION__,name[vp->namelen],name[vp->namelen+1],name[vp->namelen+2],
+		   name[vp->namelen+3],name[vp->namelen+4],msg_id);
+
+    //-------------- Try requested wire_pair ----------------//
+    if ( ( wire = header_wirePairIndex(vp,name,length, 1 /*exact = 1*/,var_len,write_method) )
+		 != MATCH_FAILED ){
+    
+		wire_index = wire;
+		if( exact ){
+			if( *length != vp->namelen+5 )
+				goto exit;
+			int_num = name[vp->namelen+4];
+		} else {
+			if( *length < vp->namelen+4 ){
+				return MATCH_FAILED;
+			} else if( *length == vp->namelen+3 ){
+				int_num = 1;
+			}else{
+				int_num = name[vp->namelen+4]+1;
+			}
+		}
+
+		if( exact ){
+			p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET,
+													  tbl[interface_ind].name,&fr1);
+		}else{
+			p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET_NEXT,
+													  tbl[interface_ind].name,&fr1);
+		}	
+		if( !p ){
+			DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Cannot allocate application frame"));
+			PDEBUG(0,"Cannot allocate application frame");
+			return MATCH_FAILED;
+		}
+	    
+		p->unit = unit_index;
+		p->side = endp_index-1;
+		p->loop = wire_index-1;
+		p->int_num = int_num;
+
+		PDEBUG(0,"(Output) unit(%d) side(%d) pair(%d) int(%d)",
+			   p->unit,p->side,p->loop,p->int_num);
+	
+		fr2 = comm_request(comm,fr1);
+		if( fr2 ){
+			p = (endp_int_payload*)comm_frame_payload(fr2);
+			//	printf("wirePair: Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);
+			perf_int = p->cntrs;
+			name[vp->namelen+4] = p->int_num;
+			*length = vp->namelen+5;
+			ret_val = name[vp->namelen+4];
+			goto exit;
+		}
+    }
+    
+    if( exact ){
+		goto exit;
+    }
+    
+    //-------------- Switch to next wire_pair ----------------//
+    if ( ( wire = header_wirePairIndex(vp,name,length, exact,var_len,write_method) )
+		 == MATCH_FAILED ){
+		goto exit;
+    }
+    wire_index = wire;
+    if( !fr1 ){
+		p = (endp_int_payload*)comm_alloc_request(msg_id,APP_GET_NEXT,
+												  tbl[interface_ind].name,&fr1);
+    }else{
+		p = (endp_int_payload*)comm_frame_payload(fr1);
+    }
+    
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Cannot allocate application frame"));
+		PDEBUG(0,"interval15Index: Cannot allocate application frame");
+		goto exit;
+    }
+
+    p->unit = unit_index;
+    p->side = endp_index-1;
+    p->loop = wire_index-1;
+    p->int_num = 1;
+
+    PDEBUG(0,"Output: unit(%d) side(%d) pair(%d) int(%d)",
+		   p->unit,p->side,p->loop,p->int_num);
+
+	if( fr2 )
+		comm_frame_free(fr2);
+    fr2 = comm_request(comm,fr1);
+    if( !fr2 ){
+    	DEBUGMSGTL(("mibII/hdsl2Shdsl","interval15Index: Error requesting\n"));
+    	PDEBUG(0,"interval15Index: Error requesting");
+		goto exit;
+    }
+
+    PDEBUG(0,"Request successfull, p =%p",p);
+    p = (endp_int_payload*)comm_frame_payload(fr2);
+    if( !p ){
+		goto exit;
+    }
+    //	printf("wirePair: Get params info for %s: units(%d) loops(%d)\n",tbl[interface_ind].name,p->units,p->loops);
+    perf_int = p->cntrs;
+    name[vp->namelen+4] = p->int_num;
+    ret_val = name[vp->namelen+4];
+    *length = vp->namelen+5;
+ exit:
+    if( fr1 )
+		comm_frame_free(fr1);
+    if( fr2 )
+		comm_frame_free(fr2);
+    PDEBUG(0,"<----------------------------");
+    return ret_val;
+}
+
+
+
+/*
+ * Segment Endpoint 15-Minute Interval Status/Performance Group 
+ */
+u_char *
+var_15MinIntervalEntry(struct variable * vp,
+					   oid * name,
+					   size_t * length,
+					   int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    endp_int_payload *p15,*p1d;
+    char *return_ptr = NULL;
+    int int_num;
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( (int_num = header_intervalIndex(vp,name,length,exact,var_len,write_method,APP_ENDP_15MIN) )
+		 == MATCH_FAILED )
+        goto exit;
+    
+	//    printf("Result : if(%s) unit(%d) side(%d) pair(%d) int(%d)\n",tbl[interface_ind].name,unit_index,endp_index,wire_index,int_num);
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_15M_ES:
+		long_return = (u_long)perf_int.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_SES:
+		long_return = (u_long)perf_int.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_CRC:
+		long_return = (u_long)perf_int.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_LOSWS:
+		long_return = (u_long)perf_int.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_15M_UAS:
+		long_return = (u_long)perf_int.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    default:
+		break;
+    }
+
+
+ exit:
+    comm_free(comm);
+    comm = NULL;
+    PDEBUG(0,"<--------------------------");
+    return return_ptr;
+}
+
+
+/*
+ * Segment Endpoint 1-Day Interval Status/Performance Group
+ */
+u_char *
+var_1DayIntervalEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    endp_int_payload *p1d;
+    char *return_ptr = NULL;
+    int int_num;
+
+	PDEBUG(0,"--------------------->");
+
+
+    comm = init_comm();
+    if(!comm){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+		return NULL;
+    }
+
+    if ( (int_num = header_intervalIndex(vp,name,length,exact,var_len,write_method,APP_ENDP_1DAY) )
+		 == MATCH_FAILED )
+        goto exit;
+    
+    PDEBUG(0,"(Result) : if(%s) unit(%d) side(%d) pair(%d) int(%d)",tbl[interface_ind].name,unit_index,endp_index,wire_index,int_num);
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case ENDP_1D_MONSECS:
+		long_return = (u_long)perf_int.mon_sec;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_ES:
+		long_return = (u_long)perf_int.es;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_SES:
+		long_return = (u_long)perf_int.ses;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_CRC:
+		long_return = (u_long)perf_int.crc;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_LOSWS:
+		long_return = (u_long)perf_int.losws;
+		return_ptr = (u_char*)&long_return;
+		break;
+    case ENDP_1D_UAS:
+		long_return = (u_long)perf_int.uas;
+		return_ptr = (u_char*)&long_return;
+		break;
+    default:
+		break;
+    }
+ exit:
+    comm_free(comm);
+    comm = NULL;
+    return return_ptr;
+}
+
+/*
+ * header_wirePairIndex:
+ * 	Defines propriate Wire pair index for incoming OID
+ *	(by now only 1 pair supported)
+ */
+
+cprof_payload _cprof;
+
+static int 
+header_confProfIndex(struct variable *vp,
+					 oid * name,
+					 size_t * length,
+					 int exact, size_t * var_len, WriteMethod ** write_method )
+{
+    int base_compare;
+    int oid_min = (vp->namelen > *length) ? *length : vp->namelen;
+    char profname[MAX_OID_LEN];
+    *write_method = 0;
+    *var_len = sizeof(long);    // default to 'long' results //
+    struct app_frame *fr1 = NULL,*fr2 = NULL;
+    char *b;
+    cprof_payload *p;
+    int i,l;
+
+
+	PDEBUG(DERR,"start");
+    if( (base_compare = snmp_oid_compare(name,oid_min,vp->name,oid_min)) > 0){
+		// OID is grater than supported
+		return MATCH_FAILED;
+    }
+
+	PDEBUG(DERR,"process...");
+    
+    if( exact ){
+		int len;
+		if( base_compare || (*length < vp->namelen) ){
+			// Already incorrect
+			return MATCH_FAILED;
+		}
+        len = *length - vp->namelen;
+        len = (len>SNMP_ADMIN_LEN) ? SNMP_ADMIN_LEN : len;
+        memcpy(profname,name+vp->namelen,len);
+		profname[len+1] = 0;	
+		p = (cprof_payload*)
+			comm_alloc_request(APP_CPROF,APP_GET,"",&fr1);
+    }else{
+		if( (base_compare < 0) || (!base_compare && *length<=vp->namelen) ){
+			memcpy((char*)name,vp->name,((int)vp->namelen)*sizeof(oid));
+			*length = vp->namelen;
+			profname[0] = 0;
+			//printf("%s: nonexact, first request\n",__FUNCTION__);
+		}else{
+			int len = *length - vp->namelen;
+			len = (len>SNMP_ADMIN_LEN) ? SNMP_ADMIN_LEN : len;
+			for(i=0;i<len;i++){
+				profname[i] = name[vp->namelen+i];
+			}
+			profname[len] = 0;
+			*length = vp->namelen;	    
+			//printf("%s: nonexact, profname=%s\n",__FUNCTION__,profname);
+		}
+		p = (cprof_payload*)
+			comm_alloc_request(APP_CPROF,APP_GET_NEXT,"",&fr1);
+    }	
+    if( !p ){
+		DEBUGMSGTL(("mibII/hdsl2Shdsl","Cannot allocate application frame"));
+		if( fr1 )
+			comm_frame_free(fr1);
+		return MATCH_FAILED;
+    }
+
+    strncpy(p->pname,profname,SNMP_ADMIN_LEN+1);
+	PDEBUG(DERR,"Request profile: %s",p->pname);
+    fr2 = comm_request(comm,fr1);
+    if( !fr2 ){
+		PDEBUG(DERR,"Error requesting");
+		if( fr1 )
+			comm_frame_free(fr1);
+		return MATCH_FAILED;
+    }
+	PDEBUG(DERR,"request successfull");
+    
+    p = (cprof_payload*)comm_frame_payload(fr2);
+    _cprof = *p;
+	PDEBUG(DERR,"get profile - %s,len=%d,vp->namelen=%d",p->pname,strnlen(p->pname,SNMP_ADMIN_LEN+1),vp->namelen);
+    l = strnlen(p->pname,SNMP_ADMIN_LEN+1);
+    for(i=0;i<l;i++){
+		name[vp->namelen+i] = p->pname[i];
+    }
+    *length += strnlen(p->pname,SNMP_ADMIN_LEN+1);
+
+printf("%s: name:\n",__FUNCTION__);
+for(i=0;i<*length;i++){
+	if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' )
+		printf("%c.",name[i]);
+	else 
+		printf("%d.",name[i]);
+}
+printf("\n");
+
+    if( fr1 )
+        comm_frame_free(fr1);
+    if( fr2 )
+        comm_frame_free(fr2);
+    return !(MATCH_FAILED);
+}
+
+u_char *
+var_SpanConfProfEntry(struct variable * vp,
+					  oid * name,
+					  size_t * length,
+					  int exact, size_t * var_len, WriteMethod ** write_method)
+{
+    char *return_ptr = NULL;
+    int i;
+
+	PDEBUG(DERR,"start");
+    comm = init_comm();
+    if(!comm){
+        DEBUGMSGTL(("mibII/hdsl2Shdsl","Error connecting to \"eocd\""));
+        return NULL;
+    }
+	PDEBUG(DERR,"Connect=OK");    
+
+printf("%s: name:\n",__FUNCTION__);
+for(i=0;i<*length;i++){
+	if( (name[i]>='a' && name[i]<='z') || (name[i]>='0' && name[i]<='9') || name[i]=='#' ){
+		printf("%c.",name[i]);
+	}else {
+		printf("%d.",name[i]);
+	}
+}
+printf("\n");
+
+    if ( header_confProfIndex(vp,name,length,exact,var_len,write_method)
+		 == MATCH_FAILED ){
+		PDEBUG(DERR,"Header_search=FAIL");
+        goto exit;
+    }
+	PDEBUG(DERR,"Header_search=OK");
+
+    //---- ack ----//
+    switch (vp->magic) {
+    case CONF_WIRE_IFACE:
+		long_return= _cprof.conf.wires;
+		return_ptr = (u_char *)&long_return;
+		PDEBUG(DINFO,"WIRE_IFACE: ret=%d", _cprof.conf.wires);
+		break;
+    case CONF_MIN_LRATE:
+		long_return = _cprof.conf.rate;
+		return_ptr = (u_char *)&long_return;
+		PDEBUG(DINFO,"MIN_LRATE: ret=%d", _cprof.conf.wires);
+		break;
+    case CONF_MAX_LRATE:
+		long_return = _cprof.conf.rate;
+		return_ptr = (u_char *)&long_return;
+		PDEBUG(DINFO,"MAX_LRATE: ret=%d", _cprof.conf.wires);
+		break;
+    case CONF_PSD:
+		long_return= _cprof.conf.psd;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*	
+			case CONF_TRNSM_MODE:
+			*var_len = sizeof(char);
+			long_return = *((unsigned char*)&info->transm_mode);
+			return_ptr = (u_char *)&long_return;
+			break; */
+    case CONF_REM_ENABLE:
+		long_return = _cprof.conf.remote_cfg;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_PWR_FEED:
+		long_return = _cprof.conf.power;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_CURR_DOWN:
+		long_return = _cprof.conf.cur_marg_down;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_WORST_DOWN:
+		long_return = _cprof.conf.worst_marg_down;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_CURR_UP:
+		long_return = _cprof.conf.cur_marg_up;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_WORST_UP:
+		long_return = _cprof.conf.worst_marg_up;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*    case CONF_USED_MARG:
+		 *var_len = sizeof(char);
+		 long_return = *((unsigned char*)&info->used_margins);
+		 return_ptr = (u_char *)&long_return; */
+    case CONF_REF_CLK:
+		long_return = _cprof.conf.clk;
+		return_ptr = (u_char *)&long_return;
+		break;
+    case CONF_LPROBE:
+		long_return = _cprof.conf.line_probe;
+		return_ptr = (u_char *)&long_return;
+		break;
+		/*    case CONF_ROW_ST:
+			  long_return = info->status;
+			  return_ptr = (u_char *)&long_return;
+		*/
+    }
+    
+	PDEBUG(DERR,"exit:");
+ exit:
+    comm_free(comm);
+    comm = NULL;    
+	PDEBUG(DERR,"return");
+    return return_ptr;
+}
+
+
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/shdsl.h net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/shdsl.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII/shdsl/shdsl.h	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII/shdsl/shdsl.h	2009-06-27 07:52:20.000000000 +0700
@@ -0,0 +1,229 @@
+/*
+ *  hdsl2,shdsl MIB (rfc- interfaces.h
+ */
+
+#ifndef _MIBGROUP_HDSL2SHDSL_H
+#define _MIBGROUP_HDSL2SHDSL_H
+
+//---- header functions ----//
+static int header_dslIfIndex(struct variable*, oid *,size_t *,
+							 int,size_t*,WriteMethod**,int *);
+
+/*---- callbacks ----*/
+extern FindVarMethod var_SpanConfEntry;
+extern FindVarMethod var_SpanStatusEntry;
+extern FindVarMethod var_InventoryEntry;
+/*
+  extern FindVarMethod var_EndpointConfEntry;
+*/
+
+extern FindVarMethod var_EndpointCurrEntry;
+
+extern FindVarMethod var_15MinIntervalEntry;
+extern FindVarMethod var_1DayIntervalEntry;
+/*
+  extern FindVarMethod var_EndpointMaintEntry;
+  extern FindVarMethod var_UnitMaintEntry;
+  // profiles
+  */
+extern FindVarMethod var_SpanConfProfEntry;
+
+/*
+  extern FindVarMethod var_EndpointAlermEntry;
+  extern FindVarMethod var_NotificationEntry;
+*/
+
+/*---- Magic values ----*/
+/*
+ * var_SpanConfEntry Magic numbers 
+ * Represents hdsl2ShdslSpanConfTable:
+ * - table indexed by {ifIndex}
+ * - each entry represents the complete span in single SHDSL line
+ * - information is persistant
+ */
+#define CONF_NREPS	0	
+#define CONF_PRFL	1	
+#define CONF_ALARMPRFL	2
+
+/*
+ * var_SpanStatusEntry Magic numbers 
+ * Represents hdsl2ShdslSpanStatusTable:
+ * - table indexed by {ifIndex},
+ * - each entry represents the complete span in single SHDSL line
+ * - information is NOT persistent
+ */
+#define STATUS_NAVAILREPS	0
+#define STATUS_MAXATTLRATE	1
+#define STATUS_ACTLRATE		2
+#define STATUS_TRNSMSNMODCUR	3
+#define STATUS_MAXATTPRATE	4
+#define STATUS_ACTPRATE		5
+
+/*
+ * var_InventoryEntry Magic numbers 
+ * Represents hdsl2ShdslInventoryTable:
+ * - table indexed by {ifIndex,hdsl2ShdslInvIndex}
+ * - info retreive via EOC from units in SHDSL line
+ * - each entry represents inventory information for a single unit in 
+ SHDSL line
+ * - information is NOT persistent
+ */
+#define INV_INDEX	0
+#define INV_VID		1
+#define INV_VMODELNUM	2
+#define INV_VSERNUM	3
+#define INV_VEOCSV	4
+#define INV_STANDARDV	5
+#define INV_VLISTNUM	6
+#define INV_VISSUENUM	7
+#define INV_VSOFTWV	8
+#define INV_EQCODE	9
+#define INV_VOTHER	10
+#define INV_TRNSMODECPB	11
+
+
+/*
+ * var_EndpointConfEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointConfTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair}
+ * - Configuration of alarm profile is setted by user
+ * - represents a single segment endpoint in an HDSL2/SHDSL line
+ * - information is persistent
+ */
+#define ENDP_SIDE	1
+#define ENDP_PAIR	2
+#define ENDP_CONF_PROF	3
+
+
+/*
+ * var_EndpointCurrEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointCurrTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair}
+ * - contains current status and performance information
+ for segment endpoints in HDSL2/SHDSL lines
+ * - information is persistent
+ */
+ 
+#define ENDP_STAT_CUR_ATN	3
+#define ENDP_STAT_CUR_SNRMGN	4
+#define ENDP_STAT_CUR_STATUS	5
+#define ENDP_STAT_CUR_ES	6
+#define ENDP_STAT_CUR_SES	7
+#define ENDP_STAT_CUR_CRC	8
+#define ENDP_STAT_CUR_LOSWS	9
+#define ENDP_STAT_CUR_UAS	10
+#define ENDP_STAT_CUR_15MEL	11
+#define ENDP_STAT_CUR_15M_ES	12
+#define ENDP_STAT_CUR_15M_SES	13
+#define ENDP_STAT_CUR_15M_CRC	14
+#define ENDP_STAT_CUR_15M_LOSWS	15
+#define ENDP_STAT_CUR_15M_UAS	16
+#define ENDP_STAT_CUR_1DEL	17
+#define ENDP_STAT_CUR_1D_ES	18
+#define ENDP_STAT_CUR_1D_SES	19
+#define ENDP_STAT_CUR_1D_CRC	20
+#define ENDP_STAT_CUR_1D_LOSWS	21
+#define ENDP_STAT_CUR_1D_UAS	22
+
+
+/*
+ * var_Endpoint15minEntry Magic numbers 
+ * Represents hdsl2Shdsl15MinIntervalTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair,hdsl2Shdsl15MinIntervalNumber}
+ * - contains history of performance information for segment endpoints in 
+ HDSL2/SHDSL lines
+ * - information is NOT persistent
+ */
+
+
+#define ENDP_15M_INT 1
+#define ENDP_15M_ES 2
+#define ENDP_15M_SES	3
+#define ENDP_15M_CRC	4
+#define ENDP_15M_LOSWS	5
+#define ENDP_15M_UAS	6
+
+
+/*
+ * var_Endpoint1dayEntry Magic numbers 
+ * Represents hdsl2Shdsl1DayIntervalTable:
+ * - table indexed by 
+ {ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide,
+ hdsl2ShdslEndpointWirePair,hdsl2Shdsl1DayIntervalNumber}
+ * - contains current status and performance information
+ for segment endpoints in HDSL2/SHDSL lines
+ * - information is persistent
+ */
+
+#define ENDP_1D_INT	1
+#define ENDP_1D_MONSECS 2
+#define ENDP_1D_ES	3
+#define ENDP_1D_SES	4
+#define ENDP_1D_CRC	5
+#define ENDP_1D_LOSWS	6
+#define ENDP_1D_UAS	7
+
+
+
+/*
+ * var_EndpointMaintEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointMaintTable:
+ * - table indexed by 
+ *	{ifIndex, hdsl2ShdslInvIndex,hdsl2ShdslEndpointSide}
+ * - supports maintenance operations (e.g., loopbacks)
+ *   to be performed on HDSL2/SHDSL segment endpoints
+ * - information is persistent
+ */
+ 
+#define ENDP_MAINT_LOOPBACK 	1
+#define ENDP_MAINT_TIPRINGREV	2
+#define ENDP_MAINT_PWRBACKOFF	3
+#define ENDP_MAINT_SOFTRESTART	4
+
+/*
+ * var_UnitMaintEntry Magic numbers 
+ * Represents hdsl2ShdslEndpointMaintTable:
+ * - table indexed by 
+ *	{ ifIndex,hdsl2ShdslInvIndex }
+ * - supports maintenance operations (e.g., loopbacks)
+ *   to be performed on HDSL2/SHDSL segment unit
+ * - information is persistent
+ */
+ 
+#define UNIT_MAINT_LPB_TO 	1
+#define UNIT_MAINT_PWR_SRC	2
+
+
+/*
+ * var_SpanConfProfEntry Magic numbers 
+ * Represents hdsl2ShdslSpanConfProfileTable
+ * - table indexed by 
+ *	{ hdsl2ShdslSpanConfProfileName }
+ * - SHDSL Line configuration profile table to be 
+ *   performed on HDSL2/SHDSL segment unit
+ * - information is persistent
+ */
+
+#define CONF_WIRE_IFACE 	1
+#define CONF_MIN_LRATE	 	2
+#define CONF_MAX_LRATE	 	3
+#define CONF_PSD	 	4
+#define CONF_TRNSM_MODE 	5
+#define CONF_REM_ENABLE 	6
+#define CONF_PWR_FEED	 	7
+#define CONF_CURR_DOWN	 	8
+#define CONF_WORST_DOWN 	9
+#define CONF_CURR_UP	 	10
+#define CONF_WORST_UP	 	11
+#define CONF_USED_MARG	 	12
+#define CONF_REF_CLK	 	13
+#define CONF_LPROBE	 	14
+#define CONF_ROW_ST	 	15
+
+#endif                          /* _MIBGROUP_HDSL2SHDSL_H */
diff -Naur net-snmp-5.1.2-old/agent/mibgroup/mibII.h net-snmp-5.1.2-new/agent/mibgroup/mibII.h
--- net-snmp-5.1.2-old/agent/mibgroup/mibII.h	2002-04-20 14:30:00.000000000 +0700
+++ net-snmp-5.1.2-new/agent/mibgroup/mibII.h	2009-06-27 07:52:20.000000000 +0700
@@ -13,3 +13,4 @@
 config_require(mibII/udp)
 config_require(mibII/vacm_vars)
 config_require(mibII/setSerialNo)
+config_require(mibII/shdsl/shdsl)
diff -Naur net-snmp-5.1.2-old/compile net-snmp-5.1.2-new/compile
--- net-snmp-5.1.2-old/compile	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/compile	2009-06-27 07:52:19.000000000 +0700
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+CC=/home/artpol/work/sigrand/projects/openwrt/midge.vlad.org.ua/trunk/openwrt-midge/staging_dir_mipsel/bin/mipsel-linux-uclibc-gcc
+CXX=/home/artpol/work/sigrand/projects/openwrt/midge.vlad.org.ua/trunk/openwrt-midge/staging_dir_mipsel/bin/mipsel-linux-uclibc-g++
+AR=/home/artpol/work/sigrand/projects/openwrt/midge.vlad.org.ua/trunk/openwrt-midge/staging_dir_mipsel/bin/mipsel-linux-uclibc-ar
+RANLIB=/home/artpol/work/sigrand/projects/openwrt/midge.vlad.org.ua/trunk/openwrt-midge/staging_dir_mipsel/bin/mipsel-linux-uclibc-ranlib
+export CXX AR RANLIB CC
+
+STAGING_DIR=/home/artpol/OpenWRT/staging_dir_mipsel/
+make LDFLAGS="-L${STAGING_DIR}/usr/lib -L${STAGING_DIR}/lib -static" all
+
diff -Naur net-snmp-5.1.2-old/configure net-snmp-5.1.2-new/configure
--- net-snmp-5.1.2-old/configure	2004-08-07 15:14:33.000000000 +0700
+++ net-snmp-5.1.2-new/configure	2009-06-27 07:52:19.000000000 +0700
@@ -27770,6 +27770,8 @@
 s,@installucdheaders@,$installucdheaders,;t t
 s,@installucdlibs@,$installucdlibs,;t t
 s,@CC@,$CC,;t t
+s,@CXX@,$CXX,;t t
+s,@AR@,$AR,;t t
 s,@CFLAGS@,$CFLAGS,;t t
 s,@LDFLAGS@,$LDFLAGS,;t t
 s,@CPPFLAGS@,$CPPFLAGS,;t t
diff -Naur net-snmp-5.1.2-old/Makefile.top net-snmp-5.1.2-new/Makefile.top
--- net-snmp-5.1.2-old/Makefile.top	2009-06-27 07:52:36.000000000 +0700
+++ net-snmp-5.1.2-new/Makefile.top	2009-06-27 07:52:20.000000000 +0700
@@ -52,6 +52,11 @@
 
 # Misc Compiling Stuff
 CC	        = @CC@
+CXX	        = @CXX@
+AR	        = @AR@
+RANLIB		= @RANLIB@
+export CXX AR RANLIB
+
 # version number is prefixed by a 0 for a better shared library version number
 #
 # ok, use libtool proper versioning:
@@ -73,6 +78,9 @@
 RANLIB		= :
 
 # libtool definitions
-.SUFFIXES: .c .o .lo
+.SUFFIXES: .c .o .lo .cpp
 .c.lo:
 	$(LIBTOOL) --mode=compile $(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
+
+.cpp.lo:
+	$(LIBTOOL) --mode=compile $(CXX) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
diff -Naur net-snmp-5.1.2-old/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt net-snmp-5.1.2-new/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt
--- net-snmp-5.1.2-old/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/mibs/HDSL2-SHDSL-LINE-MIB-rfc4319.txt	2009-06-27 07:52:19.000000000 +0700
@@ -0,0 +1,2541 @@
+-- extracted from rfc4319.txt
+-- at Thu Dec 15 06:40:11 2005
+
+   HDSL2-SHDSL-LINE-MIB DEFINITIONS ::= BEGIN
+
+   IMPORTS
+      MODULE-IDENTITY,
+      OBJECT-TYPE,
+      Counter32,
+      Unsigned32,
+      Gauge32,
+      NOTIFICATION-TYPE,
+      Integer32,
+      transmission
+         FROM SNMPv2-SMI
+      RowStatus,
+      TEXTUAL-CONVENTION
+         FROM SNMPv2-TC
+      ifIndex
+         FROM IF-MIB
+      PerfCurrentCount,
+      PerfIntervalCount
+         FROM PerfHist-TC-MIB
+      SnmpAdminString
+         FROM SNMP-FRAMEWORK-MIB
+      MODULE-COMPLIANCE,
+      OBJECT-GROUP,
+      NOTIFICATION-GROUP
+         FROM SNMPv2-CONF;
+
+   hdsl2ShdslMIB MODULE-IDENTITY
+      LAST-UPDATED "200512070000Z" -- December 7, 2005
+      ORGANIZATION "ADSLMIB Working Group"
+      CONTACT-INFO "WG-email:  adslmib@ietf.org
+         WG-URL:
+            http://www.ietf.org/html.charters/adslmib-charter.html
+         Info:       https://www1.ietf.org/mailman/listinfo/adslmib
+         Chair:      Mike Sneed
+                     Sand Channel Systems
+         Postal:     1210-203 Westview Ln
+                     Raleigh NC 27605  USA
+         Email:      sneedmike@hotmail.com
+         Phone:     +1 206 600 7022
+
+         Co-Chair    Bob Ray
+                     PESA Switching Systems, Inc.
+
+         Postal      330-A Wynn Drive
+                     Huntsville, AL 35805 USA
+         Phone       +1 256 726 9200 ext. 142
+
+         Co-editor:  Clay Sikes
+                     Zhone Technologies, Inc.
+         Postal:     8545 126th Ave. N.
+                     Largo, FL 33772 USA
+         Email:      csikes@zhone.com
+         Phone:      +1 727 530 8257
+
+         Co-editor:  Bob Ray
+                     PESA Switching Systems, Inc.
+         Postal:     330-A Wynn Drive
+                     Huntsville, AL 35805 USA
+         Email:      rray@pesa.com
+         Phone:      +1 256 726 9200 ext. 142
+
+         Co-editor:  Rajesh Abbi
+                     Alcatel USA
+         Postal:     2301 Sugar Bush Road
+                     Raleigh, NC 27612-3339 USA
+
+         Email:      Rajesh.Abbi@alcatel.com
+         Phone:      +1 919 850 6194"
+
+   DESCRIPTION
+        "This MIB module defines a collection of objects for managing
+         HDSL2/SHDSL lines.  An agent may reside at either end of the
+         line; however, the MIB module is designed to require no
+         management communication between the modems beyond that
+         inherent in the low-level EOC line protocol as defined in
+         ANSI T1E1.4/2000-006 (for HDSL2 lines) or in ITU G.991.2
+         (for SHDSL lines).
+
+         Copyright (C) The Internet Society (2005).  This version of
+         this MIB module is part of RFC 4319; see the RFC itself for
+         full legal notices."
+
+   REVISION    "200512070000Z" -- December 7, 2005
+   DESCRIPTION "This version, published as RFC 4319.
+         The following changes have been made in this version:
+           1.  Added a 3rd and 4th wire pair.
+           2.  Modified all rates such that their rates are only
+               constrained by an unsigned 32-bit value and not by
+               what today's perceived technology limitations are.
+
+           3.  Clarified that the rates from RFC 3276 include
+               payload and any applicable framing and added
+               objects for payload-only rates.
+           4.  Added an object to indicate whether the
+               tip and ring are reversed on a wire pair.
+           5.  Added an object to display the activation state
+               of a wire pair.
+           6.  Added references as necessary for clarification.
+           7.  Added display hints to textual conventions as
+               necessary.
+           8.  Updated conformance statements as necessary.
+           9.  Some changes were due to IETF requirements and
+               RFC generation tools."
+
+   REVISION    "200205090000Z" -- May 9, 2002
+   DESCRIPTION "Initial version, published as RFC 3276."
+
+   ::= { transmission 48 }
+
+   hdsl2ShdslMibObjects OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 1 }
+
+   -- Textual Conventions used in this MIB module
+   --
+
+   Hdsl2ShdslPerfCurrDayCount ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "A gauge associated with interface performance measurements in
+         a current 1-day (24 hour) measurement interval.
+
+         The value of this gauge starts at zero at the beginning of an
+         interval and is increased when associated events occur, until
+         the end of the 1-day interval.  At that time, the value of the
+         gauge is stored in the previous 1-day history interval, as
+         defined in a companion object of type
+         Hdsl2Shdsl1DayIntevalCount, and the current interval gauge
+         is restarted at zero.
+
+         In the case where the agent has no valid data available for
+         this interval, the corresponding object instance is not
+         available, and upon a retrieval request, a corresponding error
+         message shall be returned to indicate that this instance does
+         not exist.  Please note that zero is a valid value."
+      SYNTAX  Gauge32
+
+   Hdsl2Shdsl1DayIntervalCount ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "A counter associated with interface performance measurements
+         during the most previous 1-day (24 hour) measurement interval.
+         The value of this gauge is equal to the value of the current
+         day gauge, as defined in a companion object of type
+         Hdsl2ShdslPerfCurrDayCount, at the end of its most recent
+         interval.
+
+         In the case where the agent has no valid data available for
+         this interval, the corresponding object instance is not
+         available, and upon a retrieval request, a corresponding error
+         message shall be returned to indicate that this instance does
+         not exist."
+      SYNTAX  Gauge32
+
+   Hdsl2ShdslPerfTimeElapsed ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "The number of seconds that have elapsed since the beginning of
+         the current measurement period.  If, for some reason, such as
+         an adjustment in the system's time-of-day clock or the addition
+         of a leap second, the current interval exceeds the maximum
+         value, the agent will return the maximum value.
+
+         For 15-minute intervals, the range is limited to (0..899).
+         For 24-hour intervals, the range is limited to (0..86399)."
+      SYNTAX    Unsigned32(0..86399)
+
+   Hdsl2ShdslPerfIntervalThreshold ::= TEXTUAL-CONVENTION
+      DISPLAY-HINT "d"
+      STATUS    current
+      DESCRIPTION
+        "This convention defines a range of values that may be set in
+         a fault threshold alarm control.  As the number of seconds in
+         a 15-minute interval numbers at most 900, objects of this type
+         may have a range of 0...900, where the value of 0 disables the
+         alarm."
+      SYNTAX    Unsigned32(0..900)
+
+   Hdsl2ShdslUnitId ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the unique identification for all units in an
+         HDSL2/SHDSL span.  It is based on the EOC unit addressing
+         scheme with reference to the xtuC."
+      SYNTAX    INTEGER
+              {
+              xtuC(1),
+              xtuR(2),
+              xru1(3),
+              xru2(4),
+              xru3(5),
+              xru4(6),
+              xru5(7),
+              xru6(8),
+              xru7(9),
+              xru8(10)
+              }
+
+   Hdsl2ShdslUnitSide ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the referenced side of an HDSL2/SHDSL unit - Network
+         or Customer side.  The side facing the Network is the Network
+         side, while the side facing the Customer is the Customer side."
+      SYNTAX    INTEGER
+              {
+              networkSide(1),
+              customerSide(2)
+              }
+
+   Hdsl2ShdslWirePair ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "This is the referenced pair of wires in an HDSL2/SHDSL segment.
+         HDSL2 only supports a single pair (wirePair1 or two wire),
+         SHDSL lines support an optional second pair (wirePair2 or four
+         wire), and G.shdsl.bis support an optional third pair
+         (wirePair3 or six wire) and an optional fourth pair
+         (wirePair4 or eight wire)."
+      SYNTAX    INTEGER
+              {
+              wirePair1(1),    -- two wire
+              wirePair2(2),    -- four wire
+              wirePair3(3),    -- six wire
+              wirePair4(4)     -- eight wire
+              }
+
+   Hdsl2ShdslTransmissionModeType ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "Contains the regional setting of the HDSL2/SHDSL span,
+         represented as a bit-map of possible settings.  The various
+         bit positions are as follows:
+         Bit   Meaning      Description
+         1     region 1     Indicates ITU-T G.991.2 Annex A.
+         2     region 2     Indicates ITU-T G.991.2 Annex B."
+      SYNTAX      BITS
+              {
+              region1(0),
+              region2(1)
+              }
+
+   Hdsl2ShdslClockReferenceType ::= TEXTUAL-CONVENTION
+      STATUS    current
+      DESCRIPTION
+        "The various STU-C symbol clock references for the
+         HDSL2/SHDSL span, represented as an enumeration."
+      SYNTAX    INTEGER
+             {
+             localClk(1),          -- Mode-1 per G991.2
+             networkClk(2),        -- Mode-2 per G991.2
+             dataOrNetworkClk(3),  -- Mode-3a per G991.2
+             dataClk(4)            -- Mode-3b per G991.2
+             }
+
+   -- Span Configuration Group
+   --
+
+   hdsl2ShdslSpanConfTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslSpanConfEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+
+      DESCRIPTION
+        "This table supports overall configuration of HDSL2/SHDSL
+         spans.  Entries in this table MUST be maintained in a
+         persistent manner."
+      ::= { hdsl2ShdslMibObjects 1 }
+
+   hdsl2ShdslSpanConfEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslSpanConfTable.  Each entry
+         represents the complete span in a single HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the associated HDSL2/SHDSL
+         line."
+      INDEX { ifIndex }
+      ::= { hdsl2ShdslSpanConfTable 1 }
+
+   Hdsl2ShdslSpanConfEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslSpanConfNumRepeaters          Unsigned32,
+      hdsl2ShdslSpanConfProfile               SnmpAdminString,
+      hdsl2ShdslSpanConfAlarmProfile          SnmpAdminString
+      }
+
+      hdsl2ShdslSpanConfNumRepeaters OBJECT-TYPE
+      SYNTAX      Unsigned32(0..8)
+      UNITS       "repeaters"
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object provisions the number of repeaters/regenerators
+         in this HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanConfEntry 1 }
+
+   hdsl2ShdslSpanConfProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object is a pointer to a span configuration profile in
+         the hdsl2ShdslSpanConfProfileTable, which applies to this
+         span.  The value of this object is the index of the referenced
+         profile in the hdsl2ShdslSpanConfProfileTable.  Note that span
+         configuration profiles are only applicable to SHDSL lines.
+
+         HDSL2 lines MUST reference the default profile, 'DEFVAL'.
+         By default, this object will have the value 'DEFVAL'
+         (the index of the default profile).
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslSpanConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslSpanConfEntry 2 }
+
+   hdsl2ShdslSpanConfAlarmProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object is a pointer to an alarm configuration profile in
+         the hdsl2ShdslEndpointAlarmConfProfileTable.  The value of
+         this object is the index of the referenced profile in the
+         hdsl2ShdslEndpointAlarmConfProfileTable.  The alarm
+         threshold configuration in the referenced profile will be
+         used by default for all segment endpoints in this span.
+         Individual endpoints may override this profile by explicitly
+         specifying some other profile in the
+         hdsl2ShdslEndpointConfTable.  By default, this object will
+         have the value 'DEFVAL' (the index of the default
+         profile).
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslEndpointAlarmConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslSpanConfEntry 3 }
+
+   -- Span Status Group
+   --
+
+   hdsl2ShdslSpanStatusTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslSpanStatusEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+      DESCRIPTION
+        "This table provides overall status information of
+         HDSL2/SHDSL spans.  This table contains live data from
+         equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 2 }
+
+   hdsl2ShdslSpanStatusEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanStatusEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslSpanStatusTable.  Each entry
+         represents the complete span in a single HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the associated HDSL2/SHDSL
+         line."
+      INDEX { ifIndex }
+      ::= { hdsl2ShdslSpanStatusTable 1 }
+
+   Hdsl2ShdslSpanStatusEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslStatusNumAvailRepeaters        Unsigned32,
+      hdsl2ShdslStatusMaxAttainableLineRate    Unsigned32,
+      hdsl2ShdslStatusActualLineRate           Unsigned32,
+      hdsl2ShdslStatusTransmissionModeCurrent
+                           Hdsl2ShdslTransmissionModeType,
+      hdsl2ShdslStatusMaxAttainablePayloadRate Unsigned32,
+      hdsl2ShdslStatusActualPayloadRate        Unsigned32
+      }
+
+   hdsl2ShdslStatusNumAvailRepeaters OBJECT-TYPE
+      SYNTAX      Unsigned32(0..8)
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual number of repeaters/regenerators
+         discovered in this HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanStatusEntry 1 }
+
+   hdsl2ShdslStatusMaxAttainableLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the maximum attainable line rate in this HDSL2/SHDSL
+         span.  This object provides the maximum rate the line is
+         capable of achieving.  This is based upon measurements made
+         during line probing.  This rate includes payload (user data)
+         and any applicable framing overhead."
+      ::= { hdsl2ShdslSpanStatusEntry 2 }
+
+   hdsl2ShdslStatusActualLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual line rate in this HDSL2/SHDSL span.  This
+         SHOULD equal ifSpeed.  This rate includes payload (user data)
+         and any applicable framing overhead"
+      ::= { hdsl2ShdslSpanStatusEntry 3 }
+
+   hdsl2ShdslStatusTransmissionModeCurrent OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the current Power Spectral Density (PSD) regional
+         setting of the HDSL2/SHDSL span."
+      ::= { hdsl2ShdslSpanStatusEntry 4 }
+
+   hdsl2ShdslStatusMaxAttainablePayloadRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the maximum attainable payload (user data)
+         line rate in this HDSL2/SHDSL span.  This object provides
+         the maximum rate the line is capable of achieving.  This
+         is based upon measurements made during line probing.  Any
+         framing overhead is not included."
+      ::= { hdsl2ShdslSpanStatusEntry 5 }
+
+   hdsl2ShdslStatusActualPayloadRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the actual line rate in this HDSL2/SHDSL span.  Any
+         framing overhead is not included."
+      ::= { hdsl2ShdslSpanStatusEntry 6 }
+
+   -- Unit Inventory Group
+   --
+
+   hdsl2ShdslInventoryTable OBJECT-TYPE
+      SYNTAX     SEQUENCE OF Hdsl2ShdslInventoryEntry
+      MAX-ACCESS not-accessible
+      STATUS     current
+      DESCRIPTION
+        "This table supports retrieval of unit inventory information
+         available via the EOC from units in an HDSL2/SHDSL line.
+
+         Entries in this table are dynamically created during the
+         line discovery process.  The life cycle for these entries
+         is as follows:
+
+            - xtu discovers a device, either a far-end xtu or an xru
+            - an inventory table entry is created for the device
+            - the line goes down for whatever reason
+            - inventory table entries for unreachable devices are
+              destroyed
+
+         As these entries are created/destroyed dynamically, they
+         are NOT persistent."
+      ::= { hdsl2ShdslMibObjects 3 }
+
+   hdsl2ShdslInventoryEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslInventoryEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslInventoryTable.  Each entry
+         represents inventory information for a single unit in an
+         HDSL2/SHDSL line.  It is indexed by the ifIndex of the
+         HDSL2/SHDSL line and the Hdsl2ShdslUnitId of the
+         associated unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex }
+      ::= { hdsl2ShdslInventoryTable 1 }
+
+   Hdsl2ShdslInventoryEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslInvIndex                      Hdsl2ShdslUnitId,
+      hdsl2ShdslInvVendorID                   OCTET STRING,
+      hdsl2ShdslInvVendorModelNumber          OCTET STRING,
+      hdsl2ShdslInvVendorSerialNumber         OCTET STRING,
+      hdsl2ShdslInvVendorEOCSoftwareVersion   Integer32,
+      hdsl2ShdslInvStandardVersion            Integer32,
+      hdsl2ShdslInvVendorListNumber           OCTET STRING,
+      hdsl2ShdslInvVendorIssueNumber          OCTET STRING,
+      hdsl2ShdslInvVendorSoftwareVersion      OCTET STRING,
+      hdsl2ShdslInvEquipmentCode              OCTET STRING,
+      hdsl2ShdslInvVendorOther                OCTET STRING,
+      hdsl2ShdslInvTransmissionModeCapability
+                            Hdsl2ShdslTransmissionModeType
+      }
+
+   hdsl2ShdslInvIndex OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitId
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry in this table corresponds to a physical element
+         in an HDSL2/SHDSL span.  It is based on the EOC unit addressing
+         scheme with reference to the xtuC."
+      ::= { hdsl2ShdslInventoryEntry 1 }
+
+   hdsl2ShdslInvVendorID OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(8))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor ID as reported in an Inventory Response message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 25-32."
+      ::= { hdsl2ShdslInventoryEntry 2 }
+
+   hdsl2ShdslInvVendorModelNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor model number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 33-44."
+      ::= { hdsl2ShdslInventoryEntry 3 }
+
+   hdsl2ShdslInvVendorSerialNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor serial number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 45-56."
+      ::= { hdsl2ShdslInventoryEntry 4 }
+
+   hdsl2ShdslInvVendorEOCSoftwareVersion OBJECT-TYPE
+      SYNTAX      Integer32
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor EOC version as reported in a Discovery Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.2, Discovery response - Message ID
+         129, Octet 12."
+      ::= { hdsl2ShdslInventoryEntry 5 }
+
+   hdsl2ShdslInvStandardVersion OBJECT-TYPE
+      SYNTAX      Integer32
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Version of the HDSL2/SHDSL standard implemented, as reported
+         in an Inventory Response message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octet 2."
+      ::= { hdsl2ShdslInventoryEntry 6 }
+
+   hdsl2ShdslInvVendorListNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(3))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor list number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 3-5."
+      ::= { hdsl2ShdslInventoryEntry 7 }
+
+   hdsl2ShdslInvVendorIssueNumber OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(2))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor issue number as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 6-7."
+      ::= { hdsl2ShdslInventoryEntry 8 }
+
+   hdsl2ShdslInvVendorSoftwareVersion OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(6))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Vendor software version as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 8-13."
+      ::= { hdsl2ShdslInventoryEntry 9 }
+
+   hdsl2ShdslInvEquipmentCode OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(10))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Equipment code conforming to ANSI T1.213, Coded Identification
+         of Equipment Entities."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 14-23."
+      ::= { hdsl2ShdslInventoryEntry 10 }
+
+   hdsl2ShdslInvVendorOther OBJECT-TYPE
+      SYNTAX      OCTET STRING(SIZE(12))
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Other vendor information as reported in an Inventory Response
+         message."
+      REFERENCE
+        "G.991.2, Section 9.5.5.7.4, Inventory response - Message ID
+         130, Octets 57-68."
+      ::= { hdsl2ShdslInventoryEntry 11 }
+
+   hdsl2ShdslInvTransmissionModeCapability OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the transmission mode capability of the SHDSL unit."
+      ::= { hdsl2ShdslInventoryEntry 12 }
+
+   -- Segment Endpoint Configuration Group
+   --
+
+   hdsl2ShdslEndpointConfTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports configuration parameters for segment
+         endpoints in an HDSL2/SHDSL line.  As this table is indexed
+         by ifIndex, it MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 4 }
+
+   hdsl2ShdslEndpointConfEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointConfEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointConfTable.  Each entry
+         represents a single segment endpoint in an HDSL2/SHDSL line.
+         It is indexed by the ifIndex of the HDSL2/SHDSL line, the
+         UnitId of the associated unit, the side of the unit, and the
+         wire pair of the associated modem."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair}
+      ::= { hdsl2ShdslEndpointConfTable 1 }
+
+   Hdsl2ShdslEndpointConfEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointSide                   Hdsl2ShdslUnitSide,
+      hdsl2ShdslEndpointWirePair               Hdsl2ShdslWirePair,
+      hdsl2ShdslEndpointAlarmConfProfile       SnmpAdminString
+      }
+
+   hdsl2ShdslEndpointSide OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitSide
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "The side of the unit associated with this segment endpoint --
+         Network/Customer side -- as per the Hdsl2ShdslUnitSide textual
+         convention."
+      ::= { hdsl2ShdslEndpointConfEntry 1 }
+
+   hdsl2ShdslEndpointWirePair OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslWirePair
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "The wire pair of the modem associated with this segment
+         endpoint as per the Hdsl2ShdslWirePair textual convention."
+      ::= { hdsl2ShdslEndpointConfEntry 2 }
+
+   hdsl2ShdslEndpointAlarmConfProfile OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(0..32))
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the alarm threshold values to be used
+         for this segment endpoint.  The values are obtained from the
+         alarm configuration profile referenced by this object.  The
+         value of this object is the index of the referenced profile in
+         the hdsl2ShdslEndpointAlarmConfProfileTable, or NULL (a
+         zero-length SnmpAdminString).  If the value is a zero-length
+         SnmpAdminString, the endpoint uses the default Alarm
+         Configuration Profile for the associated span as per the
+         hdsl2ShdslSpanConfAlarmProfile object in the
+         hdsl2ShdslSpanConfTable.  The default value of this object is
+         a zero-length SnmpAdminString.
+
+         Any attempt to set this object to a value that is not the value
+         of the index for an active entry in the profile table,
+         hdsl2ShdslEndpointAlarmConfProfileTable, MUST be rejected."
+      ::= { hdsl2ShdslEndpointConfEntry 3 }
+
+   -- Segment Endpoint Current Status/Performance Group
+   --
+   hdsl2ShdslEndpointCurrTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointCurrEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table contains current status and performance information
+         for segment endpoints in HDSL2/SHDSL lines.  As with other
+         tables in this MIB module indexed by ifIndex, entries in this
+         table MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 5 }
+
+   hdsl2ShdslEndpointCurrEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointCurrEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointCurrTable.  Each entry
+         contains status and performance information relating to a
+         single segment endpoint.  It is indexed by the ifIndex of the
+         HDSL2/SHDSL line, the UnitId of the associated unit, the side
+         of the unit, and the wire pair of the associated modem."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair }
+      ::= { hdsl2ShdslEndpointCurrTable 1 }
+
+   Hdsl2ShdslEndpointCurrEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointCurrAtn                Integer32,
+      hdsl2ShdslEndpointCurrSnrMgn             Integer32,
+      hdsl2ShdslEndpointCurrStatus             BITS,
+      hdsl2ShdslEndpointES                     Counter32,
+      hdsl2ShdslEndpointSES                    Counter32,
+      hdsl2ShdslEndpointCRCanomalies           Counter32,
+      hdsl2ShdslEndpointLOSWS                  Counter32,
+      hdsl2ShdslEndpointUAS                    Counter32,
+      hdsl2ShdslEndpointCurr15MinTimeElapsed
+                               Hdsl2ShdslPerfTimeElapsed,
+      hdsl2ShdslEndpointCurr15MinES            PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinSES           PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinCRCanomalies  PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinLOSWS         PerfCurrentCount,
+      hdsl2ShdslEndpointCurr15MinUAS           PerfCurrentCount,
+      hdsl2ShdslEndpointCurr1DayTimeElapsed
+                                      Hdsl2ShdslPerfTimeElapsed,
+      hdsl2ShdslEndpointCurr1DayES
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DaySES
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayCRCanomalies
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayLOSWS
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurr1DayUAS
+                                     Hdsl2ShdslPerfCurrDayCount,
+      hdsl2ShdslEndpointCurrTipRingReversal    INTEGER,
+      hdsl2ShdslEndpointCurrActivationState    INTEGER
+      }
+
+   hdsl2ShdslEndpointCurrAtn OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "The current loop attenuation for this endpoint as reported in
+         a Network or Customer Side Performance Status message."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 1 }
+
+   hdsl2ShdslEndpointCurrSnrMgn OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "The current SNR margin for this endpoint as reported in a
+         Status Response/SNR message."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 2 }
+
+   hdsl2ShdslEndpointCurrStatus OBJECT-TYPE
+      SYNTAX      BITS
+                  {
+                  noDefect(0),
+                  powerBackoff(1),
+                  deviceFault(2),
+                  dcContinuityFault(3),
+                  snrMarginAlarm(4),
+                  loopAttenuationAlarm(5),
+                  loswFailureAlarm(6),
+                  configInitFailure(7),
+                  protocolInitFailure(8),
+                  noNeighborPresent(9),
+                  loopbackActive(10)
+                  }
+
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Contains the current state of the endpoint.  This is a
+         bit-map of possible conditions.  The various bit positions
+         are as follows:
+
+         noDefect               There are no defects on the line.
+
+         powerBackoff           Indicates enhanced Power Backoff.
+
+         deviceFault            Indicates that a vendor-dependent
+                                diagnostic or self-test fault
+                                has been detected.
+
+         dcContinuityFault      Indicates vendor-dependent
+                                conditions that interfere with
+                                span powering such as short and
+                                open circuits.
+
+         snrMarginAlarm         Indicates that the SNR margin
+                                has dropped below the alarm threshold.
+
+         loopAttenuationAlarm   Indicates that the loop attenuation
+                                exceeds the alarm threshold.
+
+         loswFailureAlarm       Indicates a forward LOSW alarm.
+
+         configInitFailure      Endpoint failure during initialization
+                                due to paired endpoint not able to
+                                support requested configuration.
+
+         protocolInitFailure    Endpoint failure during initialization
+                                due to incompatible protocol used by
+                                the paired endpoint.
+
+         noNeighborPresent      Endpoint failure during initialization
+                                due to no activation sequence detected
+                                from paired endpoint.
+
+         loopbackActive         A loopback is currently active at this
+                                segment endpoint.
+
+         This is intended to supplement ifOperStatus.  Note that there
+         is a 1:1 relationship between the status bits defined in this
+         object and the notification thresholds defined elsewhere in
+         this MIB module."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 3 }
+
+   hdsl2ShdslEndpointES OBJECT-TYPE
+      SYNTAX      Counter32
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) on this endpoint since the xU
+         was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 4 }
+
+   hdsl2ShdslEndpointSES OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) on this endpoint
+         since the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 5 }
+
+   hdsl2ShdslEndpointCRCanomalies OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies on this endpoint since the xU was
+         last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 6 }
+
+   hdsl2ShdslEndpointLOSWS OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds on this endpoint
+         since the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 7 }
+
+   hdsl2ShdslEndpointUAS OBJECT-TYPE
+      SYNTAX       Counter32
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) on this endpoint since
+         the xU was last restarted."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 8 }
+
+   hdsl2ShdslEndpointCurr15MinTimeElapsed OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Total elapsed seconds in the current 15-minute interval."
+      ::= { hdsl2ShdslEndpointCurrEntry 9 }
+
+   hdsl2ShdslEndpointCurr15MinES OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) in the current 15-minute
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 10 }
+
+   hdsl2ShdslEndpointCurr15MinSES OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) in the current
+         15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 11 }
+
+   hdsl2ShdslEndpointCurr15MinCRCanomalies OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies in the current 15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 12 }
+
+   hdsl2ShdslEndpointCurr15MinLOSWS OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds in the current
+         15-minute interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 13 }
+
+   hdsl2ShdslEndpointCurr15MinUAS OBJECT-TYPE
+      SYNTAX       PerfCurrentCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) in the current 15-minute
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 14 }
+
+   hdsl2ShdslEndpointCurr1DayTimeElapsed OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Number of seconds that have elapsed since the beginning of
+         the current 1-day interval."
+      ::= { hdsl2ShdslEndpointCurrEntry 15 }
+
+   hdsl2ShdslEndpointCurr1DayES OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the current day as
+         measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 16 }
+
+   hdsl2ShdslEndpointCurr1DaySES OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the current
+         day as measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 17 }
+
+   hdsl2ShdslEndpointCurr1DayCRCanomalies OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies during the current day as measured
+         by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 18 }
+
+   hdsl2ShdslEndpointCurr1DayLOSWS OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the current
+         day as measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 19 }
+
+   hdsl2ShdslEndpointCurr1DayUAS OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfCurrDayCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the current day as
+         measured by hdsl2ShdslEndpointCurr1DayTimeElapsed."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2ShdslEndpointCurrEntry 20 }
+
+   hdsl2ShdslEndpointCurrTipRingReversal OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  normal(1),
+                  reversed(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the state of the tip/ring for the
+         wire pair."
+      ::= { hdsl2ShdslEndpointCurrEntry 21 }
+
+   hdsl2ShdslEndpointCurrActivationState OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  preActivation(1),  -- PreTrain
+                  activation(2),     -- Training
+                  data(3)            -- Trained
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the activation or training state of
+         the wire pair."
+      REFERENCE   "ITU-T G.991.2, Section 6.2 PMD Activation Sequence"
+      ::= { hdsl2ShdslEndpointCurrEntry 22 }
+
+   -- Segment Endpoint 15-Minute Interval Status/Performance Group
+   --
+
+   hdsl2Shdsl15MinIntervalTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2Shdsl15MinIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table provides one row for each HDSL2/SHDSL endpoint
+         performance data collection interval.  This table contains
+         live data from equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 6 }
+
+   hdsl2Shdsl15MinIntervalEntry OBJECT-TYPE
+      SYNTAX      Hdsl2Shdsl15MinIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2Shdsl15MinIntervalTable."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair, hdsl2Shdsl15MinIntervalNumber}
+      ::= { hdsl2Shdsl15MinIntervalTable 1 }
+
+   Hdsl2Shdsl15MinIntervalEntry ::=
+      SEQUENCE
+      {
+      hdsl2Shdsl15MinIntervalNumber         Unsigned32,
+      hdsl2Shdsl15MinIntervalES             PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalSES            PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalCRCanomalies   PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalLOSWS          PerfIntervalCount,
+      hdsl2Shdsl15MinIntervalUAS            PerfIntervalCount
+      }
+
+   hdsl2Shdsl15MinIntervalNumber OBJECT-TYPE
+      SYNTAX      Unsigned32(1..96)
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Performance Data Interval number.  Interval 1 is the most
+         recent previous interval; interval 96 is 24 hours ago.
+         Intervals 2..96 are optional."
+      ::= { hdsl2Shdsl15MinIntervalEntry 1 }
+
+   hdsl2Shdsl15MinIntervalES OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 2 }
+
+   hdsl2Shdsl15MinIntervalSES OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 3 }
+
+   hdsl2Shdsl15MinIntervalCRCanomalies OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "detected CRC Anomalies"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of CRC anomalies during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 4 }
+
+   hdsl2Shdsl15MinIntervalLOSWS OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the
+         interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 5 }
+
+   hdsl2Shdsl15MinIntervalUAS OBJECT-TYPE
+      SYNTAX      PerfIntervalCount
+      UNITS       "seconds"
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the interval."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl15MinIntervalEntry 6 }
+
+   -- Segment Endpoint 1-Day Interval Status/Performance Group
+   --
+
+   hdsl2Shdsl1DayIntervalTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2Shdsl1DayIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table provides one row for each HDSL2/SHDSL endpoint
+         performance data collection interval.  This table contains
+         live data from equipment.  As such, it is NOT persistent."
+      ::= { hdsl2ShdslMibObjects 7 }
+
+   hdsl2Shdsl1DayIntervalEntry OBJECT-TYPE
+      SYNTAX      Hdsl2Shdsl1DayIntervalEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2Shdsl1DayIntervalTable."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide,
+              hdsl2ShdslEndpointWirePair, hdsl2Shdsl1DayIntervalNumber }
+      ::= { hdsl2Shdsl1DayIntervalTable 1 }
+
+   Hdsl2Shdsl1DayIntervalEntry ::=
+      SEQUENCE
+      {
+      hdsl2Shdsl1DayIntervalNumber         Unsigned32,
+      hdsl2Shdsl1DayIntervalMoniSecs       Hdsl2ShdslPerfTimeElapsed,
+      hdsl2Shdsl1DayIntervalES             Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalSES            Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalCRCanomalies   Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalLOSWS          Hdsl2Shdsl1DayIntervalCount,
+      hdsl2Shdsl1DayIntervalUAS            Hdsl2Shdsl1DayIntervalCount
+      }
+
+   hdsl2Shdsl1DayIntervalNumber OBJECT-TYPE
+      SYNTAX      Unsigned32(1..30)
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "History Data Interval number.  Interval 1 is the most
+         recent previous day; interval 30 is 30 days ago.  Intervals
+         2..30 are optional."
+      ::= { hdsl2Shdsl1DayIntervalEntry 1 }
+
+   hdsl2Shdsl1DayIntervalMoniSecs OBJECT-TYPE
+      SYNTAX       Hdsl2ShdslPerfTimeElapsed
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "The amount of time in the 1-day interval over which the
+         performance monitoring information is actually counted.
+         This value will be the same as the interval duration except
+         in a situation where performance monitoring data could not
+         be collected for any reason."
+      ::= { hdsl2Shdsl1DayIntervalEntry 2 }
+
+   hdsl2Shdsl1DayIntervalES OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Errored Seconds (ES) during the 1-day interval as
+         measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 3 }
+
+   hdsl2Shdsl1DayIntervalSES OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Severely Errored Seconds (SES) during the 1-day
+         interval as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 4 }
+
+   hdsl2Shdsl1DayIntervalCRCanomalies OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "detected CRC Anomalies"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of CRC anomalies during the 1-day interval as
+         measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 5 }
+
+   hdsl2Shdsl1DayIntervalLOSWS OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Loss of Sync Word (LOSW) Seconds during the 1-day
+         interval as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 6 }
+
+   hdsl2Shdsl1DayIntervalUAS OBJECT-TYPE
+      SYNTAX       Hdsl2Shdsl1DayIntervalCount
+      UNITS        "seconds"
+      MAX-ACCESS   read-only
+      STATUS       current
+      DESCRIPTION
+        "Count of Unavailable Seconds (UAS) during the 1-day interval
+         as measured by hdsl2Shdsl1DayIntervalMoniSecs."
+      REFERENCE   "HDSL2 Section 7.5.3.7; SHDSL Section 9.5.5.7"
+      ::= { hdsl2Shdsl1DayIntervalEntry 7 }
+
+   -- Maintenance Group
+   --
+
+   hdsl2ShdslEndpointMaintTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports maintenance operations (e.g., loopbacks)
+         to be performed on HDSL2/SHDSL segment endpoints.  This table
+         contains live data from equipment.  As such, it is NOT
+         persistent."
+      ::= { hdsl2ShdslMibObjects 8 }
+
+   hdsl2ShdslEndpointMaintEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslEndpointMaintTable.  Each entry
+         corresponds to a single segment endpoint and is indexed by the
+         ifIndex of the HDSL2/SHDSL line, the UnitId of the associated
+         unit, and the side of the unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex, hdsl2ShdslEndpointSide }
+      ::= { hdsl2ShdslEndpointMaintTable 1 }
+
+   Hdsl2ShdslEndpointMaintEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslMaintLoopbackConfig      INTEGER,
+      hdsl2ShdslMaintTipRingReversal     INTEGER,
+      hdsl2ShdslMaintPowerBackOff        INTEGER,
+      hdsl2ShdslMaintSoftRestart         INTEGER
+      }
+
+   hdsl2ShdslMaintLoopbackConfig OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  noLoopback(1),
+                  normalLoopback(2),
+                  specialLoopback(3)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object controls configuration of loopbacks for the
+         associated segment endpoint.  The status of the loopback
+         is obtained via the hdsl2ShdslEndpointCurrStatus object."
+      ::= { hdsl2ShdslEndpointMaintEntry 1 }
+
+   hdsl2ShdslMaintTipRingReversal OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  normal(1),
+                  reversed(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the state of the tip/ring pair at the
+         associated segment endpoint."
+      ::= { hdsl2ShdslEndpointMaintEntry 2 }
+
+   hdsl2ShdslMaintPowerBackOff OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  default(1),
+                  enhanced(2)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the receiver at the associated
+         segment endpoint to operate in default or enhanced power
+         backoff mode."
+      ::= { hdsl2ShdslEndpointMaintEntry 3 }
+
+   hdsl2ShdslMaintSoftRestart OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  ready(1),
+                  restart(2)
+                  }
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object enables the manager to trigger a soft restart
+         of the modem at the associated segment endpoint.  The
+         manager may only set this object to the 'restart(2)'
+         value, which initiates a restart.  The agent will perform a
+         restart after approximately 5 seconds.  Following the 5 second
+         period, the agent will restore the object to the 'ready(1)'
+         state."
+      ::= { hdsl2ShdslEndpointMaintEntry 4 }
+
+   hdsl2ShdslUnitMaintTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslUnitMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports maintenance operations for units in a
+         HDSL2/SHDSL line.  Entries in this table MUST be maintained
+         in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 9 }
+
+   hdsl2ShdslUnitMaintEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslUnitMaintEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "An entry in the hdsl2ShdslUnitMaintTable.  Each entry
+         corresponds to a single unit and is indexed by the
+         ifIndex of the HDSL2/SHDSL line and the UnitId of the
+         associated unit."
+      INDEX { ifIndex, hdsl2ShdslInvIndex  }
+      ::= { hdsl2ShdslUnitMaintTable 1 }
+
+   Hdsl2ShdslUnitMaintEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslMaintLoopbackTimeout     Integer32,
+      hdsl2ShdslMaintUnitPowerSource     INTEGER
+      }
+
+   hdsl2ShdslMaintLoopbackTimeout OBJECT-TYPE
+      SYNTAX      Integer32(0..4095)
+      UNITS       "minutes"
+      MAX-ACCESS  read-write
+      STATUS      current
+      DESCRIPTION
+        "This object configures the timeout value for loopbacks
+         initiated at segments endpoints contained in the associated
+         unit.  A value of 0 disables the timeout."
+      ::= { hdsl2ShdslUnitMaintEntry 1 }
+
+   hdsl2ShdslMaintUnitPowerSource OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  local(1),
+                  span(2)
+                  }
+      MAX-ACCESS  read-only
+      STATUS      current
+      DESCRIPTION
+        "This object indicates the DC power source being used by the
+         associated unit."
+      ::= { hdsl2ShdslUnitMaintEntry 2 }
+
+   -- Span Configuration Profile Group
+   --
+
+   hdsl2ShdslSpanConfProfileTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslSpanConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports definitions of span configuration
+         profiles for SHDSL lines.  HDSL2 does not support these
+         configuration options.  This table MUST be maintained
+         in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 10 }
+
+   hdsl2ShdslSpanConfProfileEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslSpanConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry corresponds to a single span configuration
+         profile.  Each profile contains a set of span configuration
+         parameters.  The configuration parameters in a profile are
+         applied to those lines referencing that profile (see the
+         hdsl2ShdslSpanConfProfile object).  Profiles may be
+         created/deleted using the row creation/deletion mechanism
+         via hdsl2ShdslSpanConfProfileRowStatus.  If an active
+         entry is referenced in hdsl2ShdslSpanConfProfile, the
+         entry MUST remain active until all references are removed."
+      INDEX { IMPLIED hdsl2ShdslSpanConfProfileName }
+      ::= { hdsl2ShdslSpanConfProfileTable 1 }
+
+   Hdsl2ShdslSpanConfProfileEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslSpanConfProfileName               SnmpAdminString,
+      hdsl2ShdslSpanConfWireInterface             INTEGER,
+      hdsl2ShdslSpanConfMinLineRate               Unsigned32,
+      hdsl2ShdslSpanConfMaxLineRate               Unsigned32,
+      hdsl2ShdslSpanConfPSD                       INTEGER,
+      hdsl2ShdslSpanConfTransmissionMode
+                              Hdsl2ShdslTransmissionModeType,
+      hdsl2ShdslSpanConfRemoteEnabled             INTEGER,
+      hdsl2ShdslSpanConfPowerFeeding              INTEGER,
+      hdsl2ShdslSpanConfCurrCondTargetMarginDown  Integer32,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginDown Integer32,
+      hdsl2ShdslSpanConfCurrCondTargetMarginUp    Integer32,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginUp   Integer32,
+      hdsl2ShdslSpanConfUsedTargetMargins         BITS,
+      hdsl2ShdslSpanConfReferenceClock
+                                Hdsl2ShdslClockReferenceType,
+      hdsl2ShdslSpanConfLineProbeEnable           INTEGER,
+      hdsl2ShdslSpanConfProfileRowStatus          RowStatus
+      }
+
+   hdsl2ShdslSpanConfProfileName OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This object is the unique index associated with this profile.
+         Entries in this table are referenced via the object
+         hdsl2ShdslSpanConfProfile in Hdsl2ShdslSpanConfEntry."
+      ::= { hdsl2ShdslSpanConfProfileEntry 1 }
+
+   hdsl2ShdslSpanConfWireInterface OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  twoWire(1),
+                  fourWire(2),
+                  sixWire(3),
+                  eightWire(4)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the two-wire or optional four-wire,
+         six-wire, or eight-wire operation for SHDSL lines."
+      DEFVAL      { twoWire }
+      ::= { hdsl2ShdslSpanConfProfileEntry 2 }
+
+   hdsl2ShdslSpanConfMinLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the minimum transmission rate for
+         the associated SHDSL Line in bits-per-second (bps) and includes
+         both payload (user data) and any applicable framing overhead.
+         If the minimum line rate equals the maximum line rate
+         (hdsl2ShdslSpanMaxLineRate), the line rate is considered
+         'fixed'.  If the minimum line rate is less than the
+         maximum line rate, the line rate is considered
+         'rate-adaptive'."
+      DEFVAL      { 1552000 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 3 }
+
+   hdsl2ShdslSpanConfMaxLineRate OBJECT-TYPE
+      SYNTAX      Unsigned32(0..4294967295)
+      UNITS       "bps"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the maximum transmission rate for
+         the associated SHDSL Line in bits-per-second (bps) and includes
+         both payload (user data) and any applicable framing overhead.
+         If the minimum line rate equals the maximum line rate
+         (hdsl2ShdslSpanMaxLineRate), the line rate is considered
+         'fixed'.  If the minimum line rate is less than the
+         maximum line rate, the line rate is considered
+         'rate-adaptive'."
+      DEFVAL      { 1552000 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 4 }
+
+   hdsl2ShdslSpanConfPSD OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  symmetric(1),
+                  asymmetric(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures use of symmetric/asymmetric PSD (Power
+         Spectral Density) Mask for the associated SHDSL Line.  Support
+         for symmetric PSD is mandatory for all supported data rates.
+         Support for asymmetric PSD is optional."
+      DEFVAL      { symmetric }
+      ::= { hdsl2ShdslSpanConfProfileEntry 5 }
+
+   hdsl2ShdslSpanConfTransmissionMode OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslTransmissionModeType
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the regional setting for the SHDSL
+         line."
+      DEFVAL      { { region1 } }
+      ::= { hdsl2ShdslSpanConfProfileEntry 6 }
+
+   hdsl2ShdslSpanConfRemoteEnabled OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  enabled(1),
+                  disabled(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for remote management
+         of the units in an SHDSL line from the STU-R via the EOC."
+
+      DEFVAL      { enabled }
+      ::= { hdsl2ShdslSpanConfProfileEntry 7 }
+
+   hdsl2ShdslSpanConfPowerFeeding OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  noPower(1),
+                  powerFeed(2),
+                  wettingCurrent(3)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for optional power
+         feeding in an SHDSL line."
+      DEFVAL      { noPower }
+      ::= { hdsl2ShdslSpanConfProfileEntry 8 }
+
+   hdsl2ShdslSpanConfCurrCondTargetMarginDown OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the downstream current condition target
+         SNR margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 9 }
+
+   hdsl2ShdslSpanConfWorstCaseTargetMarginDown OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the downstream worst-case target SNR
+         margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR
+         margin is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 10 }
+
+   hdsl2ShdslSpanConfCurrCondTargetMarginUp OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the upstream current-condition target
+         SNR margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 11 }
+
+   hdsl2ShdslSpanConfWorstCaseTargetMarginUp OBJECT-TYPE
+      SYNTAX      Integer32(-10..21)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object specifies the upstream worst-case target SNR
+         margin for an SHDSL line.  The SNR margin is the difference
+         between the desired SNR and the actual SNR.  Target SNR margin
+         is the desired SNR margin for a unit."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslSpanConfProfileEntry 12 }
+
+   hdsl2ShdslSpanConfUsedTargetMargins OBJECT-TYPE
+      SYNTAX      BITS
+                  {
+                  currCondDown(0),
+                  worstCaseDown(1),
+                  currCondUp(2),
+                  worstCaseUp(3)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "Indicates whether a target SNR margin is enabled or
+         disabled.  This is a bit-map of possible settings.  The
+         various bit positions are as follows:
+
+         currCondDown   - current-condition downstream target SNR
+                          margin enabled
+
+         worstCaseDown  - worst-case downstream target SNR margin
+                          enabled
+
+         currCondUp     - current-condition upstream target SNR
+                          margin enabled
+
+         worstCaseUp    - worst-case upstream target SNR margin
+                          enabled."
+
+      DEFVAL      { { currCondDown } }
+      ::= { hdsl2ShdslSpanConfProfileEntry 13 }
+
+   hdsl2ShdslSpanConfReferenceClock OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslClockReferenceType
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the clock reference for the STU-C
+         in an SHDSL Line."
+      DEFVAL      { localClk }
+      ::= { hdsl2ShdslSpanConfProfileEntry 14 }
+
+   hdsl2ShdslSpanConfLineProbeEnable OBJECT-TYPE
+      SYNTAX      INTEGER
+                  {
+                  disable(1),
+                  enable(2)
+                  }
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object enables/disables support for Line Probe of
+         the units in an SHDSL line.  When Line Probe is enabled, the
+         system performs Line Probing to find the best possible
+         rate.  If Line Probe is disabled, the rate adaptation phase
+         is skipped to shorten set up time."
+      DEFVAL      { disable }
+      ::= { hdsl2ShdslSpanConfProfileEntry 15 }
+
+   hdsl2ShdslSpanConfProfileRowStatus OBJECT-TYPE
+      SYNTAX      RowStatus
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object controls creation/deletion of the associated
+         entry in this table per the semantics of RowStatus.  If an
+         active entry is referenced in hdsl2ShdslSpanConfProfile, the
+         entry MUST remain active until all references are removed."
+      ::= { hdsl2ShdslSpanConfProfileEntry 16 }
+
+   -- Segment Endpoint Alarm Configuration Profile group
+   --
+
+   hdsl2ShdslEndpointAlarmConfProfileTable OBJECT-TYPE
+      SYNTAX      SEQUENCE OF Hdsl2ShdslEndpointAlarmConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This table supports definitions of alarm configuration
+         profiles for HDSL2/SHDSL segment endpoints.  This table
+         MUST be maintained in a persistent manner."
+      ::= { hdsl2ShdslMibObjects 11 }
+
+   hdsl2ShdslEndpointAlarmConfProfileEntry OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslEndpointAlarmConfProfileEntry
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "Each entry corresponds to a single alarm configuration profile.
+         Each profile contains a set of parameters for setting alarm
+         thresholds for various performance attributes monitored at
+         HDSL2/SHDSL segment endpoints.  Profiles may be created/deleted
+         using the row creation/deletion mechanism via
+         hdsl2ShdslEndpointAlarmConfProfileRowStatus.  If an active
+         entry is referenced in either hdsl2ShdslSpanConfAlarmProfile
+         or hdsl2ShdslEndpointAlarmConfProfile, the entry MUST remain
+         active until all references are removed."
+      INDEX { IMPLIED hdsl2ShdslEndpointAlarmConfProfileName }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileTable 1 }
+
+   Hdsl2ShdslEndpointAlarmConfProfileEntry ::=
+      SEQUENCE
+      {
+      hdsl2ShdslEndpointAlarmConfProfileName       SnmpAdminString,
+      hdsl2ShdslEndpointThreshLoopAttenuation      Integer32,
+      hdsl2ShdslEndpointThreshSNRMargin            Integer32,
+      hdsl2ShdslEndpointThreshES
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshSES
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshCRCanomalies         Integer32,
+      hdsl2ShdslEndpointThreshLOSWS
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointThreshUAS
+                                   Hdsl2ShdslPerfIntervalThreshold,
+      hdsl2ShdslEndpointAlarmConfProfileRowStatus  RowStatus
+      }
+
+   hdsl2ShdslEndpointAlarmConfProfileName OBJECT-TYPE
+      SYNTAX      SnmpAdminString (SIZE(1..32))
+      MAX-ACCESS  not-accessible
+      STATUS      current
+      DESCRIPTION
+        "This object is the unique index associated with this profile."
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 1 }
+
+   hdsl2ShdslEndpointThreshLoopAttenuation OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the loop attenuation alarm threshold.
+         When the current value of hdsl2ShdslEndpointCurrAtn reaches
+         or exceeds this threshold, an hdsl2ShdslLoopAttenCrossing
+         MAY be generated."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 2 }
+
+   hdsl2ShdslEndpointThreshSNRMargin OBJECT-TYPE
+      SYNTAX      Integer32(-127..128)
+      UNITS       "dB"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the SNR margin alarm threshold.
+         When the current value of hdsl2ShdslEndpointCurrSnrMgn
+         reaches or drops below this threshold, a
+         hdsl2ShdslSNRMarginCrossing MAY be generated."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 3 }
+
+   hdsl2ShdslEndpointThreshES OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Errored Seconds (ES) within any given 15-minute performance
+         data collection interval.  If the value of Errored Seconds
+         in a particular 15-minute collection interval reaches/
+         exceeds this value, an hdsl2ShdslPerfESThresh MAY be
+         generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 4 }
+
+   hdsl2ShdslEndpointThreshSES OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Severely Errored Seconds (SES) within any given 15-minute
+         performance data collection interval.  If the value of
+         Severely Errored Seconds in a particular 15-minute collection
+         interval reaches/exceeds this value, an hdsl2ShdslPerfSESThresh
+         MAY be generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 5 }
+
+   hdsl2ShdslEndpointThreshCRCanomalies OBJECT-TYPE
+      SYNTAX      Integer32
+      UNITS       "detected CRC Anomalies"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         CRC anomalies within any given 15-minute performance data
+         collection interval.  If the value of CRC anomalies in a
+         particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfCRCanomaliesThresh MAY be
+         generated.  At most, one notification will be sent per
+         interval per endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 6 }
+
+   hdsl2ShdslEndpointThreshLOSWS OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Loss of Sync Word (LOSW) Seconds within any given 15-minute
+         performance data collection interval.  If the value of LOSW
+         in a particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfLOSWSThresh MAY be generated.
+         At most, one notification will be sent per interval per
+         endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 7 }
+
+   hdsl2ShdslEndpointThreshUAS OBJECT-TYPE
+      SYNTAX      Hdsl2ShdslPerfIntervalThreshold
+      UNITS       "seconds"
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object configures the threshold for the number of
+         Unavailable Seconds (UAS) within any given 15-minute
+         performance data collection interval.  If the value of UAS
+         in a particular 15-minute collection interval reaches/exceeds
+         this value, an hdsl2ShdslPerfUASThresh MAY be generated.
+         At most, one notification will be sent per interval per
+         endpoint."
+      DEFVAL      { 0 }
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 8 }
+
+   hdsl2ShdslEndpointAlarmConfProfileRowStatus OBJECT-TYPE
+      SYNTAX      RowStatus
+      MAX-ACCESS  read-create
+      STATUS      current
+      DESCRIPTION
+        "This object controls creation/deletion of the associated
+         entry in this table as per the semantics of RowStatus.
+         If an active entry is referenced in either
+         hdsl2ShdslSpanConfAlarmProfile or
+         hdsl2ShdslEndpointAlarmConfProfile, the entry MUST remain
+         active until all references are removed."
+      ::= { hdsl2ShdslEndpointAlarmConfProfileEntry 9 }
+
+   -- Notifications Group
+   --
+
+   hdsl2ShdslNotifications OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 0 }
+
+   hdsl2ShdslLoopAttenCrossing NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn,
+      hdsl2ShdslEndpointThreshLoopAttenuation
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the loop attenuation
+         threshold (as per the hdsl2ShdslEndpointThreshLoopAttenuation
+         value) has been reached/exceeded for the HDSL2/SHDSL segment
+         endpoint."
+      ::= { hdsl2ShdslNotifications 1 }
+
+   hdsl2ShdslSNRMarginCrossing NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrSnrMgn,
+      hdsl2ShdslEndpointThreshSNRMargin
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the SNR margin threshold (as
+         per the hdsl2ShdslEndpointThreshSNRMargin value) has been
+         reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 2 }
+
+   hdsl2ShdslPerfESThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinES,
+      hdsl2ShdslEndpointThreshES
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the errored seconds
+         threshold (as per the hdsl2ShdslEndpointThreshES value)
+         has been reached/exceeded for the HDSL2/SHDSL segment
+         endpoint."
+      ::= { hdsl2ShdslNotifications 3 }
+
+   hdsl2ShdslPerfSESThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinSES,
+      hdsl2ShdslEndpointThreshSES
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the severely errored seconds
+         threshold (as per the hdsl2ShdslEndpointThreshSES value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 4 }
+
+   hdsl2ShdslPerfCRCanomaliesThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinCRCanomalies,
+      hdsl2ShdslEndpointThreshCRCanomalies
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the CRC anomalies threshold
+         (as per the hdsl2ShdslEndpointThreshCRCanomalies value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 5 }
+
+   hdsl2ShdslPerfLOSWSThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinLOSWS,
+      hdsl2ShdslEndpointThreshLOSWS
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the LOSW Seconds threshold
+         (as per the hdsl2ShdslEndpointThreshLOSWS value) has been
+         reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 6 }
+
+   hdsl2ShdslPerfUASThresh NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurr15MinUAS,
+      hdsl2ShdslEndpointThreshUAS
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that the unavailable seconds
+         threshold (as per the hdsl2ShdslEndpointThreshUAS value) has
+         been reached/exceeded for the HDSL2/SHDSL segment endpoint."
+      ::= { hdsl2ShdslNotifications 7 }
+
+   hdsl2ShdslSpanInvalidNumRepeaters NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfNumRepeaters
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that a mismatch has been detected
+         between the number of repeater/regenerator units configured
+         for an HDSL2/SHDSL line via the hdsl2ShdslSpanConfNumRepeaters
+         object and the actual number of repeater/regenerator units
+         discovered via the EOC."
+      ::= { hdsl2ShdslNotifications 8 }
+
+   hdsl2ShdslLoopbackFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslMaintLoopbackConfig
+      }
+      STATUS     current
+      DESCRIPTION
+        "This notification indicates that an endpoint maintenance
+         loopback command failed for an HDSL2/SHDSL segment."
+      ::= { hdsl2ShdslNotifications 9 }
+
+   hdsl2ShdslpowerBackoff NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         powerBackoff in the hdsl2ShdslEndpointCurrStatus object for
+         this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 10 }
+
+   hdsl2ShdsldeviceFault NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         deviceFault in the hdsl2ShdslEndpointCurrStatus object for
+         this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 11 }
+
+   hdsl2ShdsldcContinuityFault NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         dcContinuityFault in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 12 }
+
+   hdsl2ShdslconfigInitFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         configInitFailure in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 13 }
+
+   hdsl2ShdslprotocolInitFailure NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         protocolInitFailure in the hdsl2ShdslEndpointCurrStatus
+         object for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 14 }
+
+   hdsl2ShdslnoNeighborPresent NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrStatus
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates that the bit setting for
+         noNeighborPresent in the hdsl2ShdslEndpointCurrStatus object
+         for this endpoint has changed."
+      ::= { hdsl2ShdslNotifications 15 }
+
+   hdsl2ShdslLocalPowerLoss NOTIFICATION-TYPE
+      OBJECTS
+      {
+      hdsl2ShdslInvVendorID
+      }
+      STATUS    current
+      DESCRIPTION
+        "This notification indicates impending unit failure due to
+         loss of local power (last gasp)."
+      ::= { hdsl2ShdslNotifications 16 }
+
+   -- conformance information
+   --
+
+   hdsl2ShdslConformance OBJECT IDENTIFIER ::= { hdsl2ShdslMIB 3 }
+   hdsl2ShdslGroups      OBJECT IDENTIFIER ::=
+                { hdsl2ShdslConformance 1 }
+   hdsl2ShdslCompliances OBJECT IDENTIFIER ::=
+                { hdsl2ShdslConformance 2 }
+
+   -- agent compliance statements
+   hdsl2ShdslLineMibCompliance MODULE-COMPLIANCE
+      STATUS  deprecated
+      DESCRIPTION
+        "The compliance statement for SNMP entities that implement
+        HDSL2 and SHDSL.  The version of SHDSL supported in this
+        compliance statement is g.shdsl.
+
+        **** This compliance statement is deprecated. ****"
+      MODULE
+      MANDATORY-GROUPS
+      {
+      hdsl2ShdslSpanConfGroup,
+      hdsl2ShdslSpanStatusGroup,
+      hdsl2ShdslInventoryGroup,
+      hdsl2ShdslEndpointConfGroup,
+      hdsl2ShdslEndpointCurrGroup,
+      hdsl2Shdsl15MinIntervalGroup,
+      hdsl2Shdsl1DayIntervalGroup,
+      hdsl2ShdslMaintenanceGroup,
+      hdsl2ShdslEndpointAlarmConfGroup,
+      hdsl2ShdslNotificationGroup
+      }
+
+   GROUP  hdsl2ShdslInventoryShdslGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanShdslStatusGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanConfProfileGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   OBJECT hdsl2ShdslSpanConfWireInterface
+      SYNTAX      INTEGER
+                  {
+                  twoWire(1),
+                  fourWire(2)
+                  }
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslStatusMaxAttainableLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslStatusActualLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslSpanConfMinLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+   OBJECT hdsl2ShdslSpanConfMaxLineRate
+      SYNTAX      Unsigned32(0..4112000)
+      DESCRIPTION
+        "An implementation only has to support the range as
+        applicable for the original g.shdsl specification defined
+        in RFC 3276."
+
+      ::= { hdsl2ShdslCompliances 1 }
+
+   hdsl2GshdslbisLineMibCompliance MODULE-COMPLIANCE
+      STATUS  current
+      DESCRIPTION
+        "The compliance statement for SNMP entities that implement
+        HDSL2 and SHDSL.  The version of SHDSL supported in this
+        compliance statement is g.shdsl.bis."
+      MODULE
+      MANDATORY-GROUPS
+      {
+      hdsl2ShdslSpanConfGroup,
+      hdsl2ShdslSpanStatusGroup,
+      hdsl2ShdslInventoryGroup,
+      hdsl2ShdslEndpointConfGroup,
+      hdsl2ShdslEndpointCurrGroup,
+      hdsl2Shdsl15MinIntervalGroup,
+      hdsl2Shdsl1DayIntervalGroup,
+      hdsl2ShdslMaintenanceGroup,
+      hdsl2ShdslEndpointAlarmConfGroup,
+      hdsl2ShdslNotificationGroup
+      }
+
+   GROUP  hdsl2ShdslInventoryShdslGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanShdslStatusGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP  hdsl2ShdslSpanConfProfileGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP hdsl2ShdslWirePairGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+   GROUP hdsl2ShdslPayloadRateGroup
+      DESCRIPTION
+        "Support for this group is only required for implementations
+        supporting SHDSL lines."
+
+      ::= { hdsl2ShdslCompliances 2 }
+
+   -- units of conformance
+   --
+
+   hdsl2ShdslSpanConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfNumRepeaters,
+      hdsl2ShdslSpanConfProfile,
+      hdsl2ShdslSpanConfAlarmProfile
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for configuring span-related
+         parameters for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 1 }
+
+   hdsl2ShdslSpanStatusGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusNumAvailRepeaters
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving span-related
+         status for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 2 }
+
+   hdsl2ShdslInventoryShdslGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslInvTransmissionModeCapability
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving SHDSL-specific
+         inventory information."
+      ::= { hdsl2ShdslGroups 3 }
+
+   hdsl2ShdslSpanShdslStatusGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusMaxAttainableLineRate,
+      hdsl2ShdslStatusActualLineRate,
+      hdsl2ShdslStatusTransmissionModeCurrent
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving SHDSL-specific
+         span-related status."
+      ::= { hdsl2ShdslGroups 4 }
+
+   hdsl2ShdslInventoryGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslInvVendorID,
+      hdsl2ShdslInvVendorModelNumber,
+      hdsl2ShdslInvVendorSerialNumber,
+      hdsl2ShdslInvVendorEOCSoftwareVersion,
+      hdsl2ShdslInvStandardVersion,
+      hdsl2ShdslInvVendorListNumber,
+      hdsl2ShdslInvVendorIssueNumber,
+      hdsl2ShdslInvVendorSoftwareVersion,
+      hdsl2ShdslInvEquipmentCode,
+      hdsl2ShdslInvVendorOther
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide unit inventory
+         information about the units in HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 5 }
+
+   hdsl2ShdslEndpointConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for configuring parameters for
+         segment endpoints in HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 6 }
+
+   hdsl2ShdslEndpointCurrGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrAtn,
+      hdsl2ShdslEndpointCurrSnrMgn,
+      hdsl2ShdslEndpointCurrStatus,
+      hdsl2ShdslEndpointES,
+      hdsl2ShdslEndpointSES,
+      hdsl2ShdslEndpointCRCanomalies,
+      hdsl2ShdslEndpointLOSWS,
+      hdsl2ShdslEndpointUAS,
+      hdsl2ShdslEndpointCurr15MinTimeElapsed,
+      hdsl2ShdslEndpointCurr15MinES,
+      hdsl2ShdslEndpointCurr15MinSES,
+      hdsl2ShdslEndpointCurr15MinCRCanomalies,
+      hdsl2ShdslEndpointCurr15MinLOSWS,
+      hdsl2ShdslEndpointCurr15MinUAS,
+      hdsl2ShdslEndpointCurr1DayTimeElapsed,
+      hdsl2ShdslEndpointCurr1DayES,
+      hdsl2ShdslEndpointCurr1DaySES,
+      hdsl2ShdslEndpointCurr1DayCRCanomalies,
+      hdsl2ShdslEndpointCurr1DayLOSWS,
+      hdsl2ShdslEndpointCurr1DayUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide current status and
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 7 }
+
+   hdsl2Shdsl15MinIntervalGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2Shdsl15MinIntervalES,
+      hdsl2Shdsl15MinIntervalSES,
+      hdsl2Shdsl15MinIntervalCRCanomalies,
+      hdsl2Shdsl15MinIntervalLOSWS,
+      hdsl2Shdsl15MinIntervalUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that maintain historic
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines in 15-minute intervals."
+      ::= { hdsl2ShdslGroups 8 }
+
+   hdsl2Shdsl1DayIntervalGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2Shdsl1DayIntervalMoniSecs,
+      hdsl2Shdsl1DayIntervalES,
+      hdsl2Shdsl1DayIntervalSES,
+      hdsl2Shdsl1DayIntervalCRCanomalies,
+      hdsl2Shdsl1DayIntervalLOSWS,
+      hdsl2Shdsl1DayIntervalUAS
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that maintain historic
+         performance measurements relating to segment endpoints in
+         HDSL2/SHDSL lines in 1-day intervals."
+      ::= { hdsl2ShdslGroups 9 }
+
+   hdsl2ShdslMaintenanceGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslMaintLoopbackConfig,
+      hdsl2ShdslMaintTipRingReversal,
+      hdsl2ShdslMaintPowerBackOff,
+      hdsl2ShdslMaintSoftRestart,
+      hdsl2ShdslMaintLoopbackTimeout,
+      hdsl2ShdslMaintUnitPowerSource
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide support for
+         maintenance actions for HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 10 }
+
+   hdsl2ShdslEndpointAlarmConfGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointAlarmConfProfile,
+      hdsl2ShdslEndpointThreshLoopAttenuation,
+      hdsl2ShdslEndpointThreshSNRMargin,
+      hdsl2ShdslEndpointThreshES,
+      hdsl2ShdslEndpointThreshSES,
+      hdsl2ShdslEndpointThreshCRCanomalies,
+      hdsl2ShdslEndpointThreshLOSWS,
+      hdsl2ShdslEndpointThreshUAS,
+      hdsl2ShdslEndpointAlarmConfProfileRowStatus
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that allow configuration of alarm
+         thresholds for various performance parameters for HDSL2/SHDSL
+         lines."
+      ::= { hdsl2ShdslGroups 11 }
+
+   hdsl2ShdslNotificationGroup NOTIFICATION-GROUP
+      NOTIFICATIONS
+      {
+      hdsl2ShdslLoopAttenCrossing,
+      hdsl2ShdslSNRMarginCrossing,
+      hdsl2ShdslPerfESThresh,
+      hdsl2ShdslPerfSESThresh,
+      hdsl2ShdslPerfCRCanomaliesThresh,
+      hdsl2ShdslPerfLOSWSThresh,
+      hdsl2ShdslPerfUASThresh,
+      hdsl2ShdslSpanInvalidNumRepeaters,
+      hdsl2ShdslLoopbackFailure,
+      hdsl2ShdslpowerBackoff,
+      hdsl2ShdsldeviceFault,
+      hdsl2ShdsldcContinuityFault,
+      hdsl2ShdslconfigInitFailure,
+      hdsl2ShdslprotocolInitFailure,
+      hdsl2ShdslnoNeighborPresent,
+      hdsl2ShdslLocalPowerLoss
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports notifications of significant conditions
+         associated with HDSL2/SHDSL lines."
+      ::= { hdsl2ShdslGroups 12 }
+
+   hdsl2ShdslSpanConfProfileGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslSpanConfWireInterface,
+      hdsl2ShdslSpanConfMinLineRate,
+      hdsl2ShdslSpanConfMaxLineRate,
+      hdsl2ShdslSpanConfPSD,
+      hdsl2ShdslSpanConfTransmissionMode,
+      hdsl2ShdslSpanConfRemoteEnabled,
+      hdsl2ShdslSpanConfPowerFeeding,
+      hdsl2ShdslSpanConfCurrCondTargetMarginDown,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginDown,
+      hdsl2ShdslSpanConfCurrCondTargetMarginUp,
+      hdsl2ShdslSpanConfWorstCaseTargetMarginUp,
+      hdsl2ShdslSpanConfUsedTargetMargins,
+      hdsl2ShdslSpanConfReferenceClock,
+      hdsl2ShdslSpanConfLineProbeEnable,
+      hdsl2ShdslSpanConfProfileRowStatus
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that constitute configuration
+         profiles for configuring span-related parameters in SHDSL
+         lines."
+      ::= { hdsl2ShdslGroups 13 }
+
+   hdsl2ShdslWirePairGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslEndpointCurrTipRingReversal,
+      hdsl2ShdslEndpointCurrActivationState
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects that provide the status
+         of SHDSL-specific wire pairs."
+      ::= { hdsl2ShdslGroups 14 }
+
+   hdsl2ShdslPayloadRateGroup OBJECT-GROUP
+      OBJECTS
+      {
+      hdsl2ShdslStatusMaxAttainablePayloadRate,
+      hdsl2ShdslStatusActualPayloadRate
+      }
+      STATUS      current
+      DESCRIPTION
+        "This group supports objects for retrieving payload rates
+         that exclude any framing overhead."
+      ::= { hdsl2ShdslGroups 15 }
+
+   END
+
+-- 
+--    Copyright (C) The Internet Society (2005).
+-- 
+--    This document is subject to the rights, licenses and restrictions
+--    contained in BCP 78, and except as set forth therein, the authors
+--    retain all their rights.
+-- 
+--    This document and the information contained herein are provided on an
+--    "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+--    OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+--    ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+--    INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+--    INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+--    WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+-- 
+-- Intellectual Property
+-- 
+--    The IETF takes no position regarding the validity or scope of any
+--    Intellectual Property Rights or other rights that might be claimed to
+--    pertain to the implementation or use of the technology described in
+--    this document or the extent to which any license under such rights
+--    might or might not be available; nor does it represent that it has
+--    made any independent effort to identify any such rights.  Information
+--    on the procedures with respect to rights in RFC documents can be
+--    found in BCP 78 and BCP 79.
+-- 
+--    Copies of IPR disclosures made to the IETF Secretariat and any
+--    assurances of licenses to be made available, or the result of an
+--    attempt made to obtain a general license or permission for the use of
+--    such proprietary rights by implementers or users of this
+--    specification can be obtained from the IETF on-line IPR repository at
+--    http://www.ietf.org/ipr.
+-- 
+--    The IETF invites any interested party to bring to its attention any
+--    copyrights, patents or patent applications, or other proprietary
+--    rights that may cover technology that may be required to implement
+--    this standard.  Please address the information to the IETF at ietf-
+--    ipr@ietf.org.
+-- 
+
diff -Naur net-snmp-5.1.2-old/mibs/Makefile.in net-snmp-5.1.2-new/mibs/Makefile.in
--- net-snmp-5.1.2-old/mibs/Makefile.in	2009-06-27 07:52:36.000000000 +0700
+++ net-snmp-5.1.2-new/mibs/Makefile.in	2009-06-27 07:52:19.000000000 +0700
@@ -35,7 +35,8 @@
 	IPV6-TC.txt IPV6-MIB.txt IPV6-ICMP-MIB.txt IPV6-TCP-MIB.txt \
 	IPV6-UDP-MIB.txt \
 	DISMAN-SCRIPT-MIB.txt DISMAN-SCHEDULE-MIB.txt \
-	NOTIFICATION-LOG-MIB.txt SNMP-USM-AES-MIB.txt
+	NOTIFICATION-LOG-MIB.txt SNMP-USM-AES-MIB.txt \
+	HDSL2-SHDSL-LINE-MIB-rfc4319.txt
 
 NETSNMPMIBS = NET-SNMP-TC.txt NET-SNMP-MIB.txt NET-SNMP-AGENT-MIB.txt \
 	NET-SNMP-EXAMPLES-MIB.txt
diff -Naur net-snmp-5.1.2-old/mibs/PerfHist-TC-MIB.mib net-snmp-5.1.2-new/mibs/PerfHist-TC-MIB.mib
--- net-snmp-5.1.2-old/mibs/PerfHist-TC-MIB.mib	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/mibs/PerfHist-TC-MIB.mib	2009-06-27 07:52:19.000000000 +0700
@@ -0,0 +1,196 @@
+-- extracted from rfc2493.txt
+-- at Mon Nov 15 17:11:40 1999
+
+     PerfHist-TC-MIB DEFINITIONS ::= BEGIN
+
+     IMPORTS
+        MODULE-IDENTITY,
+        Gauge32, mib-2
+            FROM SNMPv2-SMI
+        TEXTUAL-CONVENTION
+            FROM SNMPv2-TC;
+
+
+     perfHistTCMIB MODULE-IDENTITY
+          LAST-UPDATED "9811071100Z"
+          ORGANIZATION "IETF AToMMIB and TrunkMIB WGs"
+          CONTACT-INFO
+                       "Kaj Tesink
+              Postal:  Bellcore
+                       331 Newman Springs Road
+                       Red Bank, NJ 07701
+                       USA
+              Tel:     +1 732 758 5254
+              Fax:     +1 732 758 2269
+              E-mail:  kaj@bellcore.com"
+          DESCRIPTION
+           "This MIB Module provides Textual Conventions
+             to be used by systems supporting 15 minute
+             based performance history counts."
+          ::= { mib-2 58 }
+
+
+
+
+     -- The Textual Conventions defined below are organized
+     -- alphabetically
+
+     -- Use of these TCs assumes the following:
+     -- 0  The agent supports 15 minute based history
+     --    counters.
+     -- 0  The agent is capable of keeping a history of n
+     --    intervals of 15 minute performance data. The
+     --    value of n is defined by the specific MIB
+     --    module but shall be 0 < n =< 96.
+     -- 0  The agent may optionally support performance
+     --    data aggregating the history intervals.
+     -- 0  The agent will keep separate tables for the
+     --    current interval, the history intervals, and
+     --    the total aggregates.
+     -- 0  The agent will keep the following objects.
+     --    If performance data is kept for multiple instances
+     --    of a measured entity, then
+     --    these objects are applied to each instance of
+     --    the measured entity (e.g., interfaces).
+     --
+
+
+     -- xyzTimeElapsed OBJECT-TYPE
+     --       SYNTAX  INTEGER (0..899)
+     --       MAX-ACCESS  read-only
+     --       STATUS  current
+     --       DESCRIPTION
+     --       "The number of seconds that have elapsed since
+     --       the beginning of the current measurement period.
+     --       If, for some reason, such as an adjustment in the
+     --       system's time-of-day clock, the current interval
+     --       exceeds the maximum value, the agent will return
+     --       the maximum value."
+     --       ::= { xxx }
+
+     -- xyzValidIntervals OBJECT-TYPE
+     --       SYNTAX  INTEGER (0..<n>)
+     --       MAX-ACCESS  read-only
+     --       STATUS  current
+     --       DESCRIPTION
+     --       "The number of previous near end intervals
+     --       for which data was collected.
+     --          [ The overall constraint on <n> is 1 =< n =< 96; ]
+     --          [ Define any additional constraints on <n> here. ]
+     --       The value will be <n> unless the measurement was
+     --       (re-)started within the last (<n>*15) minutes, in which
+     --       case the value will be the number of complete 15
+     --       minute intervals for which the agent has at least
+     --       some data. In certain cases (e.g., in the case
+     --       where the agent is a proxy) it is possible that some
+     --       intervals are unavailable.  In this case, this
+     --       interval is the maximum interval number for
+     --       which data is available."
+     --       ::= { xxx }
+
+     -- xyzInvalidIntervals OBJECT-TYPE
+     --     SYNTAX  INTEGER (0..<n>)
+     --     MAX-ACCESS  read-only
+     --     STATUS  current
+     --     DESCRIPTION
+     --       "The number of intervals in the range from
+     --        0 to xyzValidIntervals for which no
+     --        data is available. This object will typically
+     --        be zero except in cases where the data for some
+     --        intervals are not available (e.g., in proxy
+     --        situations)."
+     --       ::= { xxx }
+
+     PerfCurrentCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+              "A counter associated with a
+               performance measurement in a current 15
+               minute measurement interval. The value
+               of this counter starts from zero and is
+               increased when associated events occur,
+               until the end of the 15 minute interval.
+               At that time the value of the counter is
+               stored in the first 15 minute history
+               interval, and the CurrentCount is
+               restarted at zero. In the
+               case where the agent has no valid data
+               available for the current interval the
+               corresponding object instance is not
+               available and upon a retrieval request
+               a corresponding error message shall be
+               returned to indicate that this instance
+               does not exist (for example, a noSuchName
+               error for SNMPv1 and a noSuchInstance for
+               SNMPv2 GET operation)."
+            SYNTAX  Gauge32
+
+     PerfIntervalCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+              "A counter associated with a
+               performance measurement in a previous
+               15 minute measurement interval. In the
+               case where the agent has no valid data
+               available for a particular interval the
+               corresponding object instance is not
+               available and upon a retrieval request
+               a corresponding error message shall be
+               returned to indicate that this instance
+               does not exist (for example, a noSuchName
+               error for SNMPv1 and a noSuchInstance for
+               SNMPv2 GET operation).
+               In a system supporting
+               a history of n intervals with
+               IntervalCount(1) and IntervalCount(n) the
+               most and least recent intervals
+               respectively, the following applies at
+               the end of a 15 minute interval:
+               - discard the value of IntervalCount(n)
+               - the value of IntervalCount(i) becomes that
+                 of IntervalCount(i-1) for n >= i > 1
+               - the value of IntervalCount(1) becomes that
+                 of CurrentCount
+               - the TotalCount, if supported, is adjusted."
+            SYNTAX  Gauge32
+
+     PerfTotalCount ::= TEXTUAL-CONVENTION
+           STATUS  current
+           DESCRIPTION
+              "A counter associated with a
+               performance measurements aggregating the
+               previous valid 15 minute measurement
+               intervals. (Intervals for which no valid
+               data was available are not counted)"
+            SYNTAX  Gauge32
+
+
+     END
+
+-- 
+--    Copyright (C) The Internet Society (1999).  All Rights Reserved.
+-- 
+--    This document and translations of it may be copied and furnished to
+--    others, and derivative works that comment on or otherwise explain it
+--    or assist in its implementation may be prepared, copied, published
+--    and distributed, in whole or in part, without restriction of any
+--    kind, provided that the above copyright notice and this paragraph are
+--    included on all such copies and derivative works.  However, this
+--    document itself may not be modified in any way, such as by removing
+--    the copyright notice or references to the Internet Society or other
+--    Internet organizations, except as needed for the purpose of
+--    developing Internet standards in which case the procedures for
+--    copyrights defined in the Internet Standards process must be
+--    followed, or as required to translate it into languages other than
+--    English.
+-- 
+--    The limited permissions granted above are perpetual and will not be
+--    revoked by the Internet Society or its successors or assigns.
+-- 
+--    This document and the information contained herein is provided on an
+--    "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
+--    TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
+--    BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
+--    HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
+--    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
diff -Naur net-snmp-5.1.2-old/net-snmp-5.1.2-5/EXAMPLE-trap.conf net-snmp-5.1.2-new/net-snmp-5.1.2-5/EXAMPLE-trap.conf
--- net-snmp-5.1.2-old/net-snmp-5.1.2-5/EXAMPLE-trap.conf	1970-01-01 07:00:00.000000000 +0700
+++ net-snmp-5.1.2-new/net-snmp-5.1.2-5/EXAMPLE-trap.conf	2009-06-27 07:51:05.000000000 +0700
@@ -0,0 +1,18 @@
+###############################################################################
+#
+# EXAMPLE.conf:
+#   An example configuration file for configuring the ucd-snmp snmptrapd agent.
+#
+###############################################################################
+#
+# This file is intended to only be an example.  If, however, you want
+# to use it, it should be placed in /etc/snmp/snmptrapd.conf.
+# When the snmptrapd agent starts up, this is where it will look for it.
+#
+# All lines beginning with a '#' are comments and are intended for you
+# to read.  All other lines are configuration commands for the agent.
+
+#
+# PLEASE: read the snmptrapd.conf(5) manual page as well!
+#
+
